---
title: 'R-code for "Sex-specific early survival drives adult sex ratio bias and hastens
  population decline" '
author: Luke J. Eberhart-Phillips, Clemens Küpper, Tom E. X. Miller, Medardo Cruz-López,
  Kathryn Maher, Natalie dos Remedios, Martin A. Stoffel, Joseph I. Hoffman, Oliver
  Krüger, Tamás Székely
date: "October 6, 2016"
output:
  pdf_document:
    keep_tex: yes
  html_document:
    highlight: pygments
---
```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", warning = FALSE, message = FALSE)
```
In this document we provide all the necessary code for reproducing the analyses presented in our paper.  To access the dataset and Rmarkdown file, please download this [GitHub](https://github.com/leberhartphillips/Ceuta_ASR_matrix_modeling) repository.  Simply follow the link and click on *Download ZIP* on the right-hand side of the page.  An explanation of the files in the repository can be found in the Readme file.  Please don't hesitate to contact Luke at `luke.eberhart[at]gmail.com` if you have any questions.

The structure of the code we present here follows the analyses presented in the *Results* section of the paper.

**Prerequisites:**

* For running the complete code you need a `files` subfolder containing the raw data downloaded from **`data`** and **`output/bootstrap`** folders provided in the [GitHub](https://github.com/leberhartphillips/Ceuta_ASR_matrix_modeling) repository.
* The following packages are needed for analysis and can be easily installed from [CRAN](http://cran.r-project.org/) by uncommenting the `install.packages` functions:
```{r, results="hide", message=FALSE}
# install.packages("RMark")
# install.packages("stringr")
# install.packages("ggplot2")
# install.packages("dplyr")
# install.packages("grid")
# install.packages("gridExtra")
# install.packages("reshape2")
# install.packages("RColorBrewer")
# install.packages("Rmisc")
# install.packages("stats")
# install.packages("lme4")
# install.packages("magrittr")
library(RMark) 
library(stringr)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(grid)
library(reshape2)
library(RColorBrewer)
library(Rmisc)
library(stats)
library(lme4)
library(magrittr)
```
***
## Loading data

To start, please load the following datasets into your R environment:

- **data/chick_survival_data.txt** contains the mark-recapture field data of chicks. Each row is a single uniquely marked chick identified by their *ring*. The daily encounter history of an individual is expressed in their *ch*, where a "1" indicates that an individual was encountered, "0" indicates it was not encountered, and "." indicates that no survey took place on that day. *year* indicates the year during which an individual was monitored and *day_of_season* indicates the number of days since the start of the breeding season that an individual hatched. *sex* describes the molecular sex-type of an individual with "M" for males and "F" for females. *brood_ID* is a unique brood identifier for the family from which a chick hatched.

- **data/fledgling_adult_survival_data.txt** contains the mark-recapture field data of fledglings and adults. Each row is a single uniquely marked individual identified by their *ring*. The annual encounter history of an individual is expressed in their *ch*, where a "1" indicates that an individual was encountered and "0" indicates it was not encountered. *sex* describes the molecular sex-type of an individual with "M" for males and "F" for females. *age* describes the stage at which an individual was initially captured, where "J" indicates it was first captured as a chick, and "A" indicates it was first captured as an adult.

- **data/breeding_data.txt** contains the individual reproductive histories of all marked breeding adults in the population. Each row is a nesting attempt uniquely identified by the nest *ID*. *no_chicks* expresses the number of chicks that hatched from the nest. *clutch_size* indicates the number of eggs in the nest when it was initially discovered. *year* describes the year in which the nest was active. *male* and *female* indicates the unique identity of the father and mother, respectively, with "male_NA" and "female_NA" describing cases in which the other mate was not identified.
```{r, results = "hide", message = FALSE, warning=FALSE, cache = TRUE}
setwd("~/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling")
chick <- 
  read.table("data/chick_mark-recapture_data.txt",
             header = TRUE, colClasses = c("factor", "character","factor",
                                           "numeric","factor","factor", "numeric"))

fledgling_adult <- 
  read.table("data/fledgling_adult_mark-recapture_data.txt",
             header = TRUE, colClasses = c("factor","character","factor","factor"))

breeding_data <- 
  read.table("data/breeding_data.txt", 
             header = TRUE)
```
***
## Fecundity

The objective here was to determine the average per capita annual fecundity for females. This vital rate was then incorporated into the two-sex matrix model. The second objective was to evalutate if the distributions of male and female fecundity were different, which would provide evidence of the polygamous nature of the snowy plover mating system.

**Step one: wrangle the data**

Extract the female column from the breeding data, add a sex column, extract the male colum, add a 
sex column, then stack these two dataframes.
```{r, results = "hide", message = FALSE, warning=FALSE}
Sex <- rep("Female", nrow(breeding_data))
Ring <- breeding_data$female
females <- data.frame(Ring, Sex)
Sex <- rep("Male", nrow(breeding_data))
Ring <- breeding_data$male
males <- data.frame(Ring, Sex)
Individuals <- rbind(males, females)
```
replicate each row by 2 then cbind the stacked dataframe from the previous step
```{r}
reproduction_df <- cbind(breeding_data[rep(row.names(breeding_data), 2), 
                                       c("no_chicks", "clutch_size", "brood_ID", "year")],
                      Individuals)
```
change the order of the sex levels, so that females are first (for the plot)
```{r}
reproduction_df$Sex <- factor(reproduction_df$Sex, levels = c("Female", "Male"))
```
subset the data to remove entries that have a NA in the Ring column
```{r}
reproduction_df <- reproduction_df[!is.na(reproduction_df$Ring),]
```
subset the data to remove entries that have a NA in the no-chicks column
```{r}
reproduction_df <- reproduction_df[!is.na(reproduction_df$no_chicks),]
```
group data according to Year, Sex, then Ring
```{r}
reproduction_df <- dplyr::group_by(reproduction_df, year, Sex, Ring)
```
sum the total chicks produced per bird each year
```{r}
reproduction_df_sum <- 
  dplyr::ungroup(dplyr::summarise(reproduction_df, 
                           total_chicks_p_year = sum(as.numeric(no_chicks))))
```
**Step two: calculate fecundity**

calculate avg total chicks produced per bird in each year
```{r}
fecundity_annual_summary <- 
  Rmisc::summarySE(reproduction_df_sum, measurevar = "total_chicks_p_year", 
                   groupvars = c("Sex", "year"))
```
group data according to Sex then Ring
```{r}
reproduction_df_sum <- dplyr::group_by(reproduction_df_sum, Sex, Ring)
```
calculate avg total chicks produced per bird each year
```{r}
reproduction_df_sum_avg <- 
  dplyr::ungroup(dplyr::summarise(reproduction_df_sum, 
                           avg_chicks_p_year = mean(as.numeric(total_chicks_p_year))))
```
summarize the avg annual no_chicks by sex
```{r}
fecundity_sex_summary <- 
  Rmisc::summarySE(fecundity_annual_summary, 
                   measurevar = "total_chicks_p_year", groupvars = c("Sex"))
```
Determine how many individuals were included in the analysis
```{r}
sample_sizes_sex <- 
  aggregate(Ring ~ Sex, data = reproduction_df_sum_avg, FUN = function(x){NROW(x)})
```
specify the color pallete to use for the plot
```{r}
cbPalette <- RColorBrewer::brewer.pal(8, "Dark2")[c(2,1)]
```
**Step three: plot the sex-specific distributions**

```{r, fig.align="center", fig.width=2.8, fig.height=5}
Sex_specific_fucund_plot <- 
ggplot2::ggplot() +
  geom_boxplot(aes(y = avg_chicks_p_year, x = Sex, fill = Sex), 
               data = reproduction_df_sum_avg, size = .3, alpha = 0.6) +
  geom_text(data = sample_sizes_sex, size = 3, 
            aes(y = c(6.5, 6.5), x = c(1.12, 2.12), label = Ring)) +
  annotate("text", x = c(0.92, 1.92), y = c(6.5, 6.5), label = "n = ", 
           size = 3) +
  theme_bw() +
  theme(text = element_text(#family="Arial", 
                            size = 16),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x  = element_text(size = 10), 
        axis.title.y = element_text(size = 12, 
                                    margin = margin(0, 15, 0, 0)),
        axis.text.y = element_text(size = 10), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_blank(),
        panel.border = element_rect(linetype = "solid", colour = "grey")) +
  scale_fill_manual(values = cbPalette) +
  ylab("Per capita annual hatchlings parented") +
  scale_y_continuous(limits = c(0, 6.5))
Sex_specific_fucund_plot

# ggsave(Sex_specific_fucund_plot,
#        filename = "sex-specific_reproductive_success.jpg",
#        path = "figs/final/final_final",
#        width = 2.8,
#        height = 5, units = "in",
#        dpi = 300,
#        scale = 1)
```
**Step four: statistical testing of sex-specific variance in fecundity**

Run F-test to assess sex-specific variation in per capita fecundity
```{r}
reproduction_df_sum_avg <- as.data.frame(reproduction_df_sum_avg)
var.test(reproduction_df_sum_avg[which(reproduction_df_sum_avg$Sex == "Female"),
                                 c("avg_chicks_p_year")],
         reproduction_df_sum_avg[which(reproduction_df_sum_avg$Sex == "Male"),
                                 c("avg_chicks_p_year")],
         alternative = "greater")
         
```
Assign the value of female per capita annual fecundity to a constant that will be included in the one-sex matrix assessed later
```{r}
RF <- fecundity_sex_summary[1,3]
RF
```
***
## Quantifying mating system

To put our estimate of ASR in the context of breeding behavior, we quantified sex-specific mating strategies and the reproductive success of snowy plovers at our study site. Females of this species desert broods to seek serial mates (Page et al. 2009).  Thus, we expected that a larger number of females would exhibit within-season polygamy than males. 

**Step one: wrangle the data**
remove any cases in which one mate was not identified (i.e., "NA")
```{r}
mating_df <- 
  breeding_data[which(!is.na(breeding_data$female) & !is.na(breeding_data$male)),]
```
determine the number of families used in the mating system analysis (i.e. the sample size)
```{r}
length(unique(mating_df$brood_ID))
```
bind the two mates together to make a unique pair
```{r}
mating_df$pair <- as.factor(paste(mating_df$female, mating_df$male, sep = "-"))
```
determine how many mating attempts each individual had each year
```{r}
females <- reshape2::dcast(mating_df, female  ~ year)
males <- reshape2::dcast(mating_df, male  ~ year)
```
determine how many different mates each individual had over their lifetime in the popualtion
```{r}
number_males_p_female <- 
  stats::aggregate(male ~ female, mating_df, function(x) length(unique(x)))
number_females_p_male <- 
  stats::aggregate(female ~ male, mating_df, function(x) length(unique(x)))
```
join these two dataframes together and define as numeric
```{r}
females <- dplyr::inner_join(females, number_males_p_female)
females[,c(2:8)] <- 
  lapply(females[,c(2:8)], as.numeric)
males <- dplyr::inner_join(males, number_females_p_male)
males[,c(2:8)] <- 
  lapply(males[,c(2:8)], as.numeric)
```
calculate the total number of mating attempts over each individual's lifetime
```{r}
females$attempts <- rowSums(females[, c(2:8)])
males$attempts <- rowSums(males[, c(2:8)])
```
calculate the number of years breeding
```{r}
females$years <- rowSums(females[, c(2:8)] > 0)
males$years <- rowSums(males[, c(2:8)] > 0)
```
filter out all individuals that only had one mating attempt
```{r}
females_no_1 <- dplyr::filter(females, male  != 1 | years != 1 | attempts != 1)
males_no_1 <- dplyr::filter(males, female  != 1 | years != 1 | attempts != 1)
```
tidy up dataframes then bind them together
```{r}
females_no_1$sex <- "Female"
females_no_1$sex <- as.factor(females_no_1$sex)
colnames(females_no_1)[c(1,9)] <- c("focal", "mate")
males_no_1$sex <- "Male"
males_no_1$sex <- as.factor(males_no_1$sex)
colnames(males_no_1)[c(1,9)] <- c("focal", "mate")
mating <- rbind(females_no_1, males_no_1)
```
determine if an individual was either:
a) monogamous between years (i.e. only 1 mate in lifetime, with the number of attempts equaling the number years mating)
b) monogamous within years (i.e. only 1 mate in lifetime, with the number of attempts greater the number years mating)
c) polygamous between years (i.e. more than one mate in lifetime, with the number of attempts equaling the number years mating)
d) polygamous within years (i.e. more than one mate in lifetime, with the number of attempts greater the number years mating)
```{r}
mating$status <- ifelse(mating$mate == 1 & mating$years == mating$attempts, 
                        "Monogamous between years",
                    ifelse(mating$mate == 1 & mating$years < mating$attempts, 
                               "Monogamous within years",
                            ifelse(mating$mate > 1 & mating$years == mating$attempts, 
                                      "Polygamous between years",
                                  ifelse(mating$mate > 1 & mating$years < mating$attempts, 
                                             "Polygamous within years", "XXX"))))
```
calculate the number of mates per year
```{r}
mating$no_mates_per_year <- mating$mate/mating$years
```
determine "h", the average annual number of mates per female
```{r}
sex_specific_mating_system <- 
  mating%>%
    dplyr::group_by(sex)%>%
    dplyr::summarise(mean_annual_no_mates = mean(no_mates_per_year))

h <- as.numeric(sex_specific_mating_system[which(sex_specific_mating_system$sex == "Female"), 2])
```
run chi-squared test of the sex-differences in polygamy rates
```{r}
chisq.test(table(mating$sex, mating$status)[,c(3,4)])
```
run chi-squared test of the sex-differences in monogamy rates
```{r}
chisq.test(table(mating$sex, mating$status)[,c(1,2)])
```
run chi-squared test of the sex-differences in mating behaviour rates
```{r}
chisq.test(table(mating$sex, mating$status))
```
set the factor levels for plotting
```{r}
mating$status <- factor(mating$status, 
                        levels = c("Monogamous within years",
                                   "Monogamous between years",
                                   "Polygamous between years",
                                   "Polygamous within years"))
```
determine the number of males and females used in the analysis
```{r}
sample_sizes_sex <- 
  stats::aggregate(focal ~ sex, data = mating, FUN = function(x){NROW(x)})
```
define the color palatte to use in the plot
```{r}
custom_pal <- c("#7b3294", "#9E6BB1", "#91bfdb", "#4575b4")
```
plot the sex-differences in mating behaviour
```{r, fig.width=2.8, fig.height=5, fig.align="center"}
matefidelity_plot_by_sex <- 
ggplot2::ggplot() +
          geom_bar(position = "fill", alpha = 0.75, 
                   data = mating, aes(x = sex, fill = status)) +
          geom_text(data = sample_sizes_sex, size = 3, 
                    aes(y = c(1.05, 1.05), x = c(1.11, 2.11), label = focal)) +
          annotate("text", x = c(0.92, 1.92), y = c(1.05, 1.05), 
                   label = "n = ", size = 3) +
          theme_bw() +
          theme(#text = element_text(family="Arial"),
                legend.text = element_text(size = 10),
                legend.title = element_blank(),
                legend.position = "bottom",
                legend.key.height=unit(0.8,"line"),
                legend.key.width=unit(0.8,"line"),
                axis.title.x = element_blank(),
                axis.text.x  = element_text(size = 10), 
                axis.title.y = element_text(size = 12, margin = margin(0, 15, 0, 0)),
                axis.text.y = element_text(size = 10), 
                panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(),
                strip.text.x = element_text(size=12),
                strip.background = element_blank(),
                strip.text = element_text(vjust = -10),
                axis.ticks.x = element_blank(),
                axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
                axis.ticks.length = unit(0.2, "cm"),
                panel.border = element_rect(linetype = "solid", colour = "grey"),
                plot.margin = unit(c(0.2,0.2,-0.2,0.2), "cm")) +
          ylab("Proportion of individuals") +
          scale_fill_manual(values = custom_pal) +
          scale_y_continuous(limits = c(0, 1.05)) +
          guides(fill = guide_legend(ncol = 1, byrow = TRUE))
matefidelity_plot_by_sex

# ggplot2::ggsave(matefidelity_plot_by_sex,
#                 filename = "matefidelity_plot.jpg",
#                 path = "figs/final/final_final",
#                 width = 3,
#                 height = 5, units = "in",
#                 dpi = 300)
```

***
## Hatching sex ratio

The hatching sex ratio represents "rho" in the matrix model and is calculated from broods that met two criteria: 1) the brood size was the modal clutch size (3 in the case of snowy plovers), and 2) chicks were captured and sampled on the day of hatching. These criteria made sure to control for post-hatch brood mixing.

**Step one: wrangle the data**

Subset the chick mark-recapture data so that only chicks captured on the day of hatch are included. In this dataframe, the "ch" column refers to the capture history of an individual on each day of its life as a chick. Thus, if the first character of the "ch" string is a 1, it was captured on the day of hatch and is included in the hatch sex ratio dataset.
```{r}
caught_at_hatch <- chick[which(substring(chick$ch, 1, 1) == "1"),]
```
sum the number of chicks that are included for each hatch ID
```{r}
brood_ID_count <- 
caught_at_hatch %>% 
  dplyr::count(brood_ID)
```
join this data to the subset capture data
```{r}
caught_at_hatch <- dplyr::left_join(caught_at_hatch, brood_ID_count, by = "brood_ID")

```
subset these data so that clutch size equals the number of chicks sampled from each nest
```{r}
HSR_df <- caught_at_hatch[which(caught_at_hatch$clutch_size == caught_at_hatch$n),]

```
make new columns "Male" and "Female" that have 1 or 0 to describe the sex of the chick
```{r}
HSR_df$male <- ifelse(HSR_df$sex == "M", 1, 0)
HSR_df$female <- ifelse(HSR_df$sex == "F", 1, 0)
```
define hatch ID as a factor
```{r}
HSR_df$brood_ID <- as.factor(HSR_df$brood_ID)
```

**Step two: mixed effects linear regression**

Brood ID is used as a random effect to control for the non-independence of siblings
```{r}
HSR_model <- lme4::glmer(cbind(male, female) ~ (1|brood_ID),
                     data = HSR_df, family = binomial)

```
check out the model results. P = 0.588, therefore hatching sex ratio doesn't deviate from parity
```{r}
summary(HSR_model)
```
calculate what the average hatching sex ratio is summarize the data so that each row is a nest instead of an individual
```{r}
HSR_df_summary <- 
  HSR_df %>% 
  dplyr::group_by(brood_ID) %>%
  dplyr::summarise(no_males = sum(male),
                   hatch_date_season = min(day_of_season),
                   clutch_size = mean(n),
                   year = first(year))
```
calculate the proportion of the brood that was male
```{r}
HSR_df_summary$prop_male <- HSR_df_summary$no_males/HSR_df_summary$clutch_size

```
calculate the average hatching sex ratio across all nests and assign the result to a constant "HSR" to be used as rho in the matrix model
```{r}
HSR <- mean(HSR_df_summary$prop_male)
HSR
```
calculate the 95% confidence interval of the hatching sex ratio
```{r}
HSR_95CI <- c(mean(HSR_df_summary$prop_male)-
                ((sd(HSR_df_summary$prop_male)/
                    sqrt(length(HSR_df_summary$prop_male)))*1.96),
              mean(HSR_df_summary$prop_male)+
                ((sd(HSR_df_summary$prop_male)/
                    sqrt(length(HSR_df_summary$prop_male)))*1.96))
```
***
## Bootstrapping proceedure

Specify where RMark should look on your computer for Program MARK. This may vary based on your operating system (e.g., Windows, Linux, Mac OS X, etc.). This [website](http://www.phidot.org/software/mark/rmark/) provides a nice workflow for installing Program MARK and linking it to your R interface based on which operating system you have.
```{r}
MarkPath <- "/usr/local/bin/mark"
MarkViewer <- "nano"
```

**Step one: Assign functions**

The following two functions are needed to setup the projection matrix and estimate ASR.  Load these before implementing the bootstrap simulation.

**plover_matrix()** builds the two-sex Lefkovitch matrix using the vital rates specified in the *demographic_rates* object.
```{r}
plover_matrix <- 
  function(demographic_rates){
      # Define plover life-stages of the Ceuta snowy plover matrix model
      stages <- c("F_1st_yr",  "F_Adt",  "M_1st_yr",  "M_Adt")
      # Build the 4x4 matrix
      result <- 
        matrix(c(
                 # top row of matrix
                 0, NA, 0, NA, 
                 # second row of matrix
                 (demographic_rates$F_Chk_survl*demographic_rates$F_Fdg_survl),
                 demographic_rates$F_Adt_survl,
                 0, 0,
                 # third row of matrix
                 0, NA, 0, NA,
                 # fourth row of matrix
                 0, 0, 
                 (demographic_rates$M_Chk_survl*demographic_rates$M_Fdg_survl),
                 demographic_rates$M_Adt_survl),
               nrow = length(stages), byrow = TRUE,
               dimnames = list(stages, stages))
      result
  }
```

**matrix_ASR()** calculates the ASR of the population based on the two-sex two-stage projection matrix built by the *plover_matrix()* function. Arguments in the function include:
*A* is an two sex x by x projection matrix
*n* is an x lengthed vector representing starting stage distribution (the default is a vector with 10 individuals in each stage)

```{r}
matrix_ASR <-
  function(M, n = rep(10, nrow(M)), h = 1, k = 3, iterations = 1000, HSR = 0.5, plot = FALSE){
    # Number of stages in matrix
    x <- length(n)
    # Number of time steps to simulate
    t <- iterations
    # an empty t by x matrix to store the stage distributions
    stage <- matrix(numeric(x * t), nrow = x)
    # an empty t vector to store the population sizes
    pop <- numeric(t)
    # for loop that goes through each of t time steps
    for (i in 1:t) {
      # stage distribution at time t
      stage[,i] <- n
      # population size at time t
      pop[i] <- sum(n)
      # number of male adults at time t
      M2 <- stage[4, i]
      # number of female adults at time t
      F2 <- stage[2, i]
      # Female freq-dep fecundity of Female chicks
      M[1,x/2]        <- (k*M2)/(M2+(F2*h))*HSR
      # Female freq-dep fecundity of Male chicks
      M[(x/4)*3,x/2]  <- (k*M2)/(M2+(F2*h))*HSR
      # Male freq-dep fecundity of Female chicks
      M[1,x]          <- (k*F2)/(M2+(F2*h))*HSR
      # Male freq-dep fecundity of Male chicks
      M[(x/4)*3,x]    <- (k*F2)/(M2+(F2*h))*HSR
      # define the new n (i.e., new stage distribution at time t)
      n <- M %*% n
      # define rownames of stage matrix
      rownames(stage) <- rownames(M)
      # define colnames of stage matrix
      colnames(stage) <- 0:(t - 1)
      # calculate the proportional stable stage distribution
      stage <- apply(stage, 2, function(x) x/sum(x))
      # define stable stage as the last stage
      stable.stage <- stage[, t]
    }
    # calc ASR as the proportion of the adult stable stage class that is male
    ASR <- stable.stage[x]/(stable.stage[x/2] + stable.stage[x])

    if(plot)
    {
      # plot distrubution to assure that it is not chaotic
      matplot(rownames(t(stage)), t(stage), type='l', lwd=2, las=1)
    }
    # make a list of results
    pop.proj <- list(ASR = ASR,
                     lambda = pop[t]/pop[t - 1],
                     stable.stage = stable.stage,
                     stage.vectors = stage,
                     SSD_M2 = stable.stage[4],
                     SSD_F2 = stable.stage[2])
    # print the list as output to the function
    pop.proj
  }
```

**Step two: running the bootstrap**

Each iteration will do the following computational steps:

A) Load the following function **bootstrap_data()** to randomly sample with replacement from the *chick* and *fledgling_adult* datasets, while making sure that if an individual existing in both datasets was sampled from the *chick* data it was also sampled in the *fledgling_adult* data. Each bootstrapped sample has the same length as the original data.
```{r}
bootstrap_data <- function(fledgling_adult, chick) {
  
  # sample a new chick mark-recapture dataset the same size as the original, 
  # with replacement
  chick_boot <- chick[sample(1:nrow(chick), 
                             size = nrow(chick), 
                             replace = TRUE), ]
  
  # determine if there are any individuals in the new chick data that are in the 
  # adult data
  present <- fledgling_adult$bird_ID %in% chick_boot$bird_ID
  
  # extract these individuals from the adult data
  fledgling_adult_boot1 <- fledgling_adult[present, ]
  
  # determine the left over adults
  spare_fledgling_adult <- fledgling_adult[!present, ]
  
  # randomly sample from these left over adults
  fledgling_adult_boot2 <- 
    spare_fledgling_adult[sample(1:nrow(spare_fledgling_adult), 
                                 size = nrow(fledgling_adult) - 
                                   nrow(fledgling_adult_boot1), 
                                 replace = TRUE), ]
  
  # bind these two adult samples together
  fledgling_adult_boot <- rbind(fledgling_adult_boot1, fledgling_adult_boot2)
  
  # make a list of these two datasets, which will be used in the next function
  out <- list(chick_boot = chick_boot, fledgling_adult_boot = fledgling_adult_boot)
}
```
B) The next function, **bootstrap_survival_ASR()**, runs the survival analyses and estimates the ASR of the bootstrapped sample created from **bootstrap_data()**. In the function, *plover_boot_list* is the output list from **bootstrap_data()** and *num_boot* is the bootstrap number in the loop (leave unspecified).
```{r}
bootstrap_survival_ASR <- function(plover_boot_list, num_boot) {
  
  # specify the bootstrapped data samples (from the previous function)
  chick <- plover_boot_list[["chick_boot"]]
  fledgling_adult <- plover_boot_list[["fledgling_adult_boot"]]
  
  # remove ring column
  fledgling_adult <- fledgling_adult[,-1]
  chick <- chick[,-1]
  
  # Create processed RMark data formatted as Cormack-Jolly_Seber with 2 groups 
  # (sex and age initally ringed), starting at year 2006, two age groups
  # (first-years and adults) in which the first-year stage only lasts for 
  # one year.
  fledgling_adult.proc <- RMark::process.data(fledgling_adult, model = "CJS",
                                              groups = c("sex", "age"),
                                              begin.time = 2006, age.var = 2, 
                                              initial.age = c(1, 0))
  
  # Create processed RMARK data format as Cormack-Jolly_Seber with 3 groups 
  # (sex, year, and brood ID).
  chick.proc <-  RMark::process.data(chick, model = "CJS",
                                     groups = c("sex", "year", "brood_ID"))
  
  # Create the design matrix from the processed mark-recapture datasets
  fledgling_adult.ddl <- RMark::make.design.data(fledgling_adult.proc)
  chick.ddl <- RMark::make.design.data(chick.proc)
  
  # adds first-year / adult age field to design data in column "Age"
  fledgling_adult.ddl <- RMark::add.design.data(data = fledgling_adult.proc,
                                                ddl = fledgling_adult.ddl, 
                                                parameter = "Phi", 
                                                type = "age",
                                                bins = c(0, 1, 7), right = FALSE,
                                                name = "age", replace = TRUE)
  
  # create a dummy field in the design matrix called marked.as.adult 
  # which is "0" for the group initally ringed as chicks and "1" for the group
  # marked as adults.
  fledgling_adult.ddl$Phi$marked.as.adult = 0
  fledgling_adult.ddl$Phi$marked.as.adult[fledgling_adult.ddl$Phi$initial.age.class=="A"]=1 
  fledgling_adult.ddl$p$marked.as.adult = 0
  fledgling_adult.ddl$p$marked.as.adult[fledgling_adult.ddl$p$initial.age.class=="A"]=1
  
  # check parameter matrices to see if groups were binned correctly 
  # (uncomment the next three lines to assess)
  # PIMS(mark(fledgling_adult.proc, fledgling_adult.ddl,
  #           model.parameters = list(Phi = list(formula = ~ age + sex)), 
  #           output = F), "Phi")
   
  # Create quadratic time variable so that it can be tested for temporal variation 
  # chick survival (i.e. non-linear relationship between daily chick survival and age)
  time <- c(0:(chick.proc$nocc[1] - 1))
  quadratic <- time^2
  quad_time <- data.frame(time, quadratic)
  chick.ddl$p <- 
    RMark::merge_design.covariates(chick.ddl$Phi,
                                   quad_time, bygroup = FALSE, bytime = TRUE)
  chick.ddl$Phi <- 
    RMark::merge_design.covariates(chick.ddl$Phi,
                                   quad_time, bygroup = FALSE, bytime = TRUE)
  
  # create the function that specifies the candidate models of fledgling and adult 
  # resight probability
  fledgling_adult_survival = function() 
  {
    # sex- and stage-specific survival:
    Phi.agexsex = list(formula = ~ age * sex) 

    # Models exploring variation in encounter probability
    # constant:
    p.dot = list(formula =  ~ 1)
    # sex-dependent:
    p.sex = list(formula =  ~ sex)
    # age-dependent:
    p.age = list(formula =  ~ age)
    # factorial variation across year:
    p.Time = list(formula =  ~ Time)
    # interaction between sex and factorial year:
    p.sexxTime = list(formula =  ~ sex * Time)
    # interaction between age and factorial year:
    p.agexTime = list(formula =  ~ age * Time)
    # interaction between age and sex:
    p.agexsex = list(formula =  ~ age * sex)
    # additive effects of sex and factorial year:
    p.sex_Time = list(formula =  ~ sex + Time)
    # additive effects of age and factorial year:
    p.age_Time = list(formula =  ~ age + Time)
    # additive effects of age and sex:
    p.age_sex = list(formula =  ~ age + sex)
    # additive effects of sex, age, factorial year:
    p.Time_age_sex = list(formula =  ~ Time + age + sex)
    # additive effect of year and interaction between age and sex:
    p.Time_age_x_sex = list(formula =  ~ Time + age * sex)
    
    # create a list of candidate models for all the a models above that begin with 
    # either "Phi." or "p."
    cml <-  RMark::create.model.list("CJS")
    
    # specify the data, design matrix, delete unneeded output files, and 
    # run the models in Program MARK
    model.list <-  RMark::mark.wrapper(cml, data = fledgling_adult.proc, 
                                       ddl = fledgling_adult.ddl, delete = TRUE)
    
    # output the model list and sotre the results
    return(model.list)
  }
  
  # Run the models on the bootstrapped data
  fledgling_adult_survival_run <- 
    fledgling_adult_survival()
  
  # Extract the AIC model table from the model output
  AIC_table_fledgling_adult <- 
    fledgling_adult_survival_run$model.table
  
  # Find the model number for the first ranked model of the AIC table
  model_fledgling_adult_num <- 
    as.numeric(rownames(fledgling_adult_survival_run$model.table[1,]))
  
  # extract and format survival rates from fledgling and adult model output
  fledgling_adult_reals <- 
    fledgling_adult_survival_run[[model_fledgling_adult_num]]$results$real
  
  # format the output to tidy up the sex- and age-specific effects
  Groups <- data.frame(str_split_fixed(rownames(fledgling_adult_reals), " ", n = 5))
  fledgling_adult_reals <- cbind(Groups, fledgling_adult_reals)
  fledgling_adult_reals <- 
    fledgling_adult_reals[which(fledgling_adult_reals$X1 == "Phi"),]
  fledgling_adult_reals$age <- 
    unlist(str_extract_all(fledgling_adult_reals$X2,"[AJ]"))
  fledgling_adult_reals$age <- 
    as.factor(ifelse(fledgling_adult_reals$age == "A","Adult","Fledgling"))
  fledgling_adult_reals$sex <- 
    unlist(str_extract_all(fledgling_adult_reals$X2,"[FM]"))
  fledgling_adult_reals$sex <- 
    as.factor(ifelse(fledgling_adult_reals$sex == "F","Female","Male"))
  fledgling_adult_reals$sex_age <- 
    paste(fledgling_adult_reals$sex,fledgling_adult_reals$age,sep = "_")
  fledgling_adult_survival_real <- 
    fledgling_adult_reals[,c("sex_age", "estimate")]
  row.names(fledgling_adult_survival_real) <- NULL
  
  # Do the same for chicks. create the function that specifies the candidate models 
  # of chick resight probability
  chick_survival = function() 
  {
    # sex- and quadratic age-specific survival:
    Phi.quadratic.x.sex = list(formula = ~ sex * quadratic)
    
    # Models exploring variation in encounter probability
    # constant:
    p.dot = list(formula = ~ 1)
    # quadratic across age
    p.quadratic = list(formula = ~ quadratic)
    # annual variation
    p.year = list(formula = ~ year)
    # sex-specific
    p.sex = list(formula = ~ sex)
    # interaction between year and quadratic age
    p.year.x.quadratic = list(formula = ~ year * quadratic)
    # interaction between year and quadratic age
    p.sex.x.quadratic = list(formula = ~ sex * quadratic)
    # additive effects of sex and linear age
    p.sex.quadratic = list(formula = ~ sex + quadratic)
    # additive effects of year and quadratic age
    p.year.quadratic = list(formula = ~ year + quadratic)
    # additive effects of year, sex, and quadratic age
    p.year.quadratic.Sex = list(formula = ~ year + quadratic + sex)
    # additive effect of year and interaction between sex and quadratic age
    p.year.quadratic.x.Sex = list(formula = ~ year + quadratic * sex)

    # create a list of candidate models for all the a models above that begin with 
    # either "Phi." or "p."
    cml <-  RMark::create.model.list("CJS")
    
    # specify the data, design matrix, delete unneeded output files, and 
    # run the models in Program MARK
    model.list <-  RMark::mark.wrapper(cml, data = chick.proc, 
                                       ddl = chick.ddl, delete = TRUE)
    
    # output the model list and sotre the results
    return(model.list)
  }
  
  # Run the models on the bootstrapped data
  chick_survival_run <- chick_survival()
  
  # Extract the AIC model table from the model output
  AIC_table_chick <- chick_survival_run$model.table
  
  # Find the model number for the first ranked model of the AIC table
  model_chick_num <- as.numeric(rownames(chick_survival_run$model.table[1,]))
  
  # extract real parameter estimates from top models
  chick_reals <- chick_survival_run[[model_chick_num]]$results$real
  
  # format the output to tidy up the sex- and age-specific effects
  Groups <- data.frame(str_split_fixed(rownames(chick_reals), " ", n = 5))
  chick_reals <- cbind(Groups, chick_reals)
  chick_reals <- chick_reals[which(chick_reals$X1 == "Phi"),]
  chick_reals$sex <- unlist(str_extract_all(chick_reals$X2,"[FM]"))
  chick_reals$sex <- as.factor(ifelse(chick_reals$sex == "F","Female","Male"))
  
  # transform the daily chick survival (DCS) to apparent hatching success
  # by calculating the product of all DCS estimates:
    plover_Survival_to_Fledge_F <- 
      prod(chick_reals[which(chick_reals$sex == "Female"),
                       c("estimate")][c(1:26)])
    plover_Survival_to_Fledge_M <- 
      prod(chick_reals[which(chick_reals$sex == "Male"),
                       c("estimate")][c(1:26)])
  
  # tidy up the output and put it in a dataframe.
  estimate <- c(plover_Survival_to_Fledge_F, plover_Survival_to_Fledge_M)
  sex <- c("Female", "Male")
  age <- c("Chick", "Chick")
  sex_age <- paste(sex, age, sep = "_")
  chick_survival_real <- data.frame(sex_age, estimate)
  
  # Bind the fledgling and adult dataframe with the chicks
  survival_rates <- rbind(fledgling_adult_survival_real, chick_survival_real)
  
  # Create a list of demographic rates from the survival analyses above
  demographic_rates <- list(F_Chk_survl = survival_rates[5,2],
                            F_Fdg_survl = survival_rates[3,2],
                            F_Adt_survl = survival_rates[1,2],
                            M_Chk_survl = survival_rates[6,2],
                            M_Fdg_survl = survival_rates[4,2],
                            M_Adt_survl = survival_rates[2,2],
                            # Define hatching sex ratio
                            HSR = HSR,
                            # Define the mating system (h), and clutch size (k)
                            h = h,
                            k = 3)
  
  # Build matrix based on rates specified in the list above
  demographic_matrix <- plover_matrix(demographic_rates)
  
  # Determine the ASR at the stable stage distribution
  ASR_SSD <- matrix_ASR(M = demographic_matrix, h = demographic_rates$h,
                        HSR = demographic_rates$HSR, iterations = 1000)
  
  # Extract ASR
  ASR_estimate <- ASR_SSD$ASR
  
  # make a list of all the results from this iteration
  bootstrap_results_list <- 
    list(AIC_table_chick, 
         AIC_table_fledgling_adult, 
         survival_rates,
         ASR_estimate)
}
```
C) Create a function to run the **bootstrap_data()** and **bootstrap_survival_ASR()** functions in sequence.
```{r}
run_bootstrap_survival_ASR <- function(num_boot, fledgling_adult, chick)
  {
  # run the sampling function and specify the datasets
  bootstrap_data_list <- bootstrap_data(fledgling_adult, chick)
  
  # run the survival analysis and ASR deduction on the sampled data
  result <- bootstrap_survival_ASR(bootstrap_data_list, num_boot)
}
```
D) Specify the number of iterations to run in the bootstrap (1000 was used in our analysis).
```{r}
niter <- 1000
```
E) start the bootstrap (takes approx. 130 hours on an Intel XEON E5v2 series sever with 40 threads)
```{r}
# uncomment this to run the bootstrap. To bypass this, load the bootstrap output datasets 
# below to continue analysis

# survival_ASR_bootstrap_result <- 
#   sapply(1:niter, run_bootstrap_survival_ASR, fledgling_adult, chick)
```
F) Extract data from the bootstrap output (uncomment these sections if you ran the bootstrap)

AIC tables of chick survival for each interation
```{r}
# AIC_table_chick_boot <- 
# do.call(rbind, lapply(seq(from = 1, to = niter * 4, by = 4), 
#                       function(x) survival_ASR_bootstrap_result[[x]]))
# num_mods <- nrow(AIC_table_chick_boot)/niter
# AIC_table_chick_boot$iter <- rep(1:niter, each = num_mods)
```
AIC tables of fledgling and adult survival for each interation
```{r}
# AIC_table_fledgling_adult_boot <- 
# do.call(rbind, lapply(seq(from = 2, to = niter * 4, by = 4), 
#                       function(x) survival_ASR_bootstrap_result[[x]]))
# num_mods <- nrow(AIC_table_fledgling_adult_boot)/niter
# AIC_table_fledgling_adult_boot$iter <- rep(1:niter, each = num_mods)
```
Survival rates for each iteration
```{r}
# survival_rates_boot <- 
# do.call(rbind, lapply(seq(from = 3, to = niter * 4, by = 4), 
#                       function(x) survival_ASR_bootstrap_result[[x]]))
# survival_rates_boot$iter <- rep(1:niter, each = 6)
```
ASR estimate for each iteration
```{r}
# ASR_boot <- 
# sapply(seq(from = 4, to = niter * 4, by = 4), 
#        function(x) survival_ASR_bootstrap_result[[x]])
# ASR_boot <- data.frame(ASR_boot = unname(ASR_boot), iter = 1:niter)
```
To save your time with re-running the bootstrap, here are the four datasets produced by the bootstrap:

- **output/bootstrap/AIC_table_chick_boot_out.txt** contains the bootstrap output for model selection of chick survival based on the mark-recapture analysis run in Program MARK. Each row is a *model* fitted via maximum likelihood to the bootstrapped data sample of each iteration (*iter*). *Phi* describes the model structure for fitting daily survival. *p* describes the model structure for fitting daily encounter probability. *npar* reveals the number of parameters used in a given model. *AICc* is the Akaike Information Criteria statistic corrected for small sample size. *DeltaAICc* is the difference in AICc between a given model and the best fit model of a given iteration. *weight* describes the AIC weight of a given model. *Deviance* describes the deviance of a given model.

- **output/bootstrap/AIC_table_fledgling_adult_boot_out.txt** contains the bootstrap output for model selection of fledgling and adult survival based on the mark-recapture analysis run in Program MARK. Each row is a *model* fitted via maximum likelihood to the bootstrapped data sample of each iteration (*iter*). *Phi* describes the model structure for fitting annual survival. *p* describes the model structure for fitting annual encounter probability. *npar* reveals the number of parameters used in a given model. *AICc* is the Akaike Information Criteria statistic corrected for small sample size. *DeltaAICc* is the difference in AICc between a given model and the best fit model of a given iteration. *weight* describes the AIC weight of a given model. *Deviance* describes the deviance of a given model.

- **output/bootstrap/ASR_boot_out.txt** contains the adult sex ratio estimates (*ASR_boot*) of each iteration of the bootstrap procedure. Each row represents an iteration (*iter*).

- **output/bootstrap/survival_rates_boot_out.txt** contains the sex- and stage-specific survival estimates (*estimate*) of each iteration (*iter*) in the bootstrap procedure. Each row represents a given sex and stage (*sex_age*) in a given iteration.
```{r, cache = TRUE}
setwd("~/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling")
chick_AIC_tables <- 
  read.table("output/bootstrap/AIC_table_chick_boot_out.txt", header = TRUE)

fldg_ad_AIC_tables <- 
  read.table("output/bootstrap/AIC_table_fledgling_adult_boot_out.txt", header = TRUE)

survival_rates_boot <- 
  read.table("output/bootstrap/survival_rates_boot_out.txt", header = TRUE)

ASR_boot <- 
  read.table("output/bootstrap/ASR_boot_out.txt", header = TRUE)
```
***
## Visualizations of bootstrap results

**Sex-biases in survial across chicks, fledglings, and adults**

We visualized sex-bias in stage-specific survival rates with violin plots.  These plots are useful for illustrating the spread of the bootstrap distribution. We have also added the inter-quartile ranges as horizontal bars within the violins. Before plotting, the sex-bias at each stage for each bootstrap iteration needs to be calculated.  This is done with the **sex_diff_surv()** function and specifying the output list from the bootstrap above.
```{r}
sex_diff_survival <- function(survival_rates_boot) {
  
  # make an empty datarame to store the results
  sex_diff_surv_output <- data.frame(Adult = numeric(niter),
                                     Fledgling = numeric(niter),
                                     Chick = numeric(niter))
  
  # for loop to go through each iteration and calculate the differece between 
  # female and male survival rates for each stage.
  for(i in 1:niter){
    Adult <- 
      survival_rates_boot[which(survival_rates_boot$iter == i), 2][2] -
      survival_rates_boot[which(survival_rates_boot$iter == i), 2][1]
    Fledgling <- 
      survival_rates_boot[which(survival_rates_boot$iter == i), 2][4] -
      survival_rates_boot[which(survival_rates_boot$iter == i), 2][3]
    Chick <- 
      survival_rates_boot[which(survival_rates_boot$iter == i), 2][6] -
      survival_rates_boot[which(survival_rates_boot$iter == i), 2][5]
    
    sex_diff_surv_output[i, 1] <- Adult
    sex_diff_surv_output[i, 2] <- Fledgling
    sex_diff_surv_output[i, 3] <- Chick
  }
  
  # restructure the output and lable columns
  sex_diff_surv_output <- reshape2::melt(data = sex_diff_surv_output)
  colnames(sex_diff_surv_output) <- c("stage", "difference")
  
  # return the output
  sex_diff_surv_output
}
```
run the function on the bootstrap list from above
```{r}
sex_diff_survival_output <- sex_diff_survival(survival_rates_boot)
```
calculate some summary statistics
```{r}
sex_diff_survival_summary <- 
    sex_diff_survival_output %>%
    dplyr::group_by(stage) %>%
    dplyr::summarise(avg = mean(difference),
                     median = median(difference),
                     var = var(difference))
```
specify custom color palette to distingush first-year stages (i.e. chicks and fledglings) from adults
```{r}
cbPalette <- c("#A6A6A6", "#D9D9D9", "#D9D9D9")
```
reorder the levels of the stage factors
```{r}
sex_diff_survival_output$stage <- 
  factor(sex_diff_survival_output$stage, levels = c("Adult", "Fledgling", "Chick"))
```
plot the sex-biases in survival across the three stages
```{r, fig.height=4, fig.width=4, fig.align="center"}
Background <- 
  ggplot(aes(y = difference, x = stage, fill = stage), data = sex_diff_survival_output) + 
  coord_flip() +
  theme_bw() +
  annotate("rect", xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=0, alpha=0.6,
           fill=brewer.pal(8, "Dark2")[c(2)]) +
  annotate("rect", xmin=-Inf, xmax=Inf, ymin=0, ymax=Inf, alpha=0.6,
           fill=brewer.pal(8, "Dark2")[c(1)]) +
  # annotate("text", x = c(2,2), y = c(-Inf, Inf),
  #          label = c("\u2640", "\u2642"), size = 7,
  #          family="Arial", vjust = c(0.5,0.5), hjust = c(-0.3,1.3)) +
  annotate("text", x = 2, y = -0.25,
           label = c("female"), size = 5,
           vjust = c(0.5), hjust = c(0.5), angle = 90) +
  annotate("text", x = 2, y = 0.25,
           label = c("male"), size = 5,
           vjust = c(0.5), hjust = c(0.5), angle = 270) +
  theme(text = element_text(#family="Arial", 
                            color = "white"),
        legend.position = "none",
        axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
        axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)), 
        axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
        axis.text.y  = element_text(size=10, angle = 0, hjust = 1, margin = margin(0, 5, 0, 0)),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_line(size = 0.5, colour = "white"),
        axis.ticks.length = unit(0.2, "cm"),
        panel.border = element_blank(),
        plot.margin = unit(c(1,0.5,0.5,0.5), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank()) +
  scale_x_continuous(limits=c(0,4),breaks=c(0,1,2), labels=c("Chick", "Fledgling", "Adult")) +
  scale_y_continuous(limits=c(-0.25,0.25)) +
  xlab("Life-stage") + 
  ylab("Sex-bias in apparent survival (phi)")
  # ylab("Sex-bias in apparent survival (\u03D5)")

Bootstrap_sex_diff_VR_plot <- 
  ggplot(aes(y = difference, x = stage, fill = stage), data = sex_diff_survival_output) + 
  coord_flip() +
  theme_bw() +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +
  theme(#text = element_text(family="Arial"),
        legend.position = "none",
        panel.background = element_rect(fill = "transparent",colour = NA),
        plot.background = element_rect(fill = "transparent",colour = NA),
        axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
        axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)), 
        axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
        axis.text.y  = element_text(size=10, angle = 0, hjust = 1, margin = margin(0, 5, 0, 0)),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        panel.border = element_rect(linetype = "solid", colour = "grey"),
        plot.margin = unit(c(1,0.5,0.5,0.5), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank()) +
  scale_fill_manual(values = cbPalette) +
  scale_y_continuous(limits=c(-0.25,0.25)) +
  xlab("Life-stage") + 
  # ylab("Sex-bias in apparent survival (\u03D5)")
  ylab("Sex-bias in apparent survival (phi)")

# jpeg(filename = "/Users/Luke/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/figs/final/final_final/Surv_sex_differences_final.jpeg",
#      quality = 100,
#      width = 4,
#      height = 4,
#      units = "in",
#      res = 300)

grid.newpage()
pushViewport( viewport( layout = grid.layout( 1 , 1 , widths = unit( 1 , "npc" ) ) ) )
print( Background + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
print( Bootstrap_sex_diff_VR_plot + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
# dev.off()
```

**Adult sex ratio distribution**

calculate the confidence interval, mean, and median of the ASR bootstraps
```{r}
CI <- 0.95
ASR_boot_95CI <- stats::quantile(ASR_boot$ASR_boot, c((1 - CI)/2, 1 - (1 - CI)/2), na.rm = TRUE)
ASR_boot_mean <- mean(ASR_boot$ASR_boot)
ASR_boot_median <- median(ASR_boot$ASR_boot)
```
consolidate the results
```{r}
ASR_boot_summary <- as.data.frame(cbind(ASR_boot_95CI[1], ASR_boot_95CI[2], 
                                        ASR_boot_mean, ASR_boot_median))
rownames(ASR_boot_summary) <- NULL
colnames(ASR_boot_summary) <- c("lcl", "ucl", "mean", "median")
```
We visualized the bootstrapped results of adult sex ratio with a histogram. The horizontal black bar above the distribution illustrates the 95% confidence interval of the 1000 iterations.
```{r, fig.height=3, fig.width=4, fig.align="center"}
ASR_bootstrap_histogram <- 
ggplot2::ggplot() +
          annotate("rect", xmin=-Inf, xmax=0.5, ymin=-Inf, ymax=Inf, alpha=0.6,
                   fill=brewer.pal(8, "Dark2")[c(2)]) +
          annotate("rect", xmin=0.5, xmax=Inf, ymin=-Inf, ymax=Inf, alpha=0.6,
                   fill=brewer.pal(8, "Dark2")[c(1)]) +
          annotate("text", x = c(-Inf,Inf), y = c(75, 95),
                   label = c("female", "male"), size = 5,
                   vjust = c(1.5,1.5), hjust = c(0,0), angle = c(90, 270)) +
          # annotate("text", x = c(-Inf,Inf), y = c(75, 75),
          #          label = c("\u2640", "\u2642"), size = 7,
          #          family="Arial", vjust = c(1.5,1.5), hjust = c(-0.5,1.5)) +
          geom_histogram(binwidth = 0.02, data = ASR_boot, aes(x = ASR_boot)) +
          geom_errorbarh(data = ASR_boot_summary, 
                         aes(y = 120, x = lcl, xmin = lcl, xmax = ucl), 
                         color = "black", size = 0.8, linetype = "solid") +
          theme_bw() +
          theme(#text = element_text(family="Arial"),
                legend.position="none",
                legend.position = c(0, 1), 
                legend.justification = c(0, 1),
                legend.text=element_text(size=11),
                legend.title=element_blank(),
                legend.key.height=unit(0.8,"line"),
                legend.key.width=unit(0.8,"line"),
                legend.background = element_rect(fill=NA),
                axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
                axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)), 
                axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
                axis.text.y  = element_text(size=10, angle = 0, hjust = 1, 
                                            margin = margin(0, 5, 0, 0), color = "black"),
                axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
                axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
                axis.ticks.length = unit(0.2, "cm"),
                panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(),
                panel.border = element_rect(linetype = "solid", colour = "grey"),
                plot.margin = unit(c(1,0.5,0.5,0.5), "cm"),
                strip.background = element_blank(), 
                strip.text = element_blank(),
                panel.margin = unit(0.75, "lines")) +
          ylab("Frequency") +
          # xlab("Adult sex ratio (proportion \u2642)") +
          xlab("Adult sex ratio (proportion male)") +
          scale_x_continuous(limits = c(0.0, 1)) +
          scale_y_continuous(limits = c(0, 125))
ASR_bootstrap_histogram

# ggsave(ASR_bootstrap_histogram,
#        filename = "ASR_distribution_mating_function.jpg",
#        path = "figs/final/final_final",
#        width = 4,
#        height = 3, units = "in",
#        dpi = 300,
#        scale = 1)
```

**AIC model selection summary (panels in Supplementary Material Figure 1)**

To illustrate the mark-recapture model selection going on during the bootstrap, we summarized AIC statistics for each model included in the survival analysis and visualized with ranked boxplots

First, wrangle the bootstrap AIC table output
```{r}
# define the model number
chick_AIC_tables$model_number <- as.numeric(chick_AIC_tables$model)

fldg_ad_AIC_tables$model_number <- as.numeric(fldg_ad_AIC_tables$model)

# summarize the average AIC stats for each candidate model across all 1000 iterations
chick_AIC_tables_summary <- 
  chick_AIC_tables %>%
  dplyr::group_by(model) %>%
  dplyr::summarise(avg_Delta = mean(DeltaAICc),
            IQR_Delta = IQR(DeltaAICc),
            avg_Weight = mean(weight),
            IQR_Weight = IQR(weight))

fldg_ad_AIC_tables_summary <- 
  fldg_ad_AIC_tables %>%
  dplyr::group_by(model) %>%
  dplyr::summarise(avg_Delta = mean(DeltaAICc),
            IQR_Delta = IQR(DeltaAICc),
            avg_Weight = mean(weight),
            IQR_Weight = IQR(weight))

# rank the output by delta AIC and determine model number
chick_AIC_tables_summary <- dplyr::arrange(chick_AIC_tables_summary, avg_Delta)
chick_AIC_tables_summary$model_number <- as.numeric(chick_AIC_tables_summary$model)

fldg_ad_AIC_tables_summary <- dplyr::arrange(fldg_ad_AIC_tables_summary, avg_Delta)
fldg_ad_AIC_tables_summary$model_number <- as.numeric(fldg_ad_AIC_tables_summary$model)

# merge the two datasets for plotting
chick_AIC_tables <- 
  dplyr::left_join(chick_AIC_tables_summary, chick_AIC_tables, by = "model_number")

fldg_ad_AIC_tables <- 
  dplyr::left_join(fldg_ad_AIC_tables_summary, fldg_ad_AIC_tables, by = "model_number")

# extract the model structure explaining resighting probability
chick_AIC_tables$p <- 
  factor(chick_AIC_tables$p, 
         levels = str_sub(as.character(chick_AIC_tables_summary$model), 
                          start = 24, end = str_length(chick_AIC_tables_summary$model)-1))

fldg_ad_AIC_tables$p <- 
  factor(fldg_ad_AIC_tables$p,
         levels = str_sub(as.character(fldg_ad_AIC_tables_summary$model), 
                        start = 18, end = str_length(fldg_ad_AIC_tables_summary$model)-1))
```
plot the overall model ranks of the chick survival anlaysis based on Delta AIC
```{r, fig.height=5, fig.width=6, fig.align="center"}
Bootstrap_Delta_AIC_plot_C <- 
  ggplot(aes(y = DeltaAICc, x = p), data = chick_AIC_tables) + 
  theme_bw() +
  #geom_violin(fill = "grey40") +
  geom_boxplot(width = 0.3, fill = "grey70", outlier.size = 0.5) +
  theme(#text = element_text(family="Arial"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x  = element_blank(), 
        axis.title.y = element_text(size=12, margin = margin(0, 18, 0, 0)),
        axis.text.y  = element_text(size=10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        plot.margin = unit(c(0.5,0.5,0,0.5), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank()) +
  scale_y_continuous(limits=c(0,50)) +
  xlab("Model") + 
  ylab("Delta AIC") +
  #ylab("\u0394 AIC") +
  ggtitle("Chicks resighting model selection")
```
plot the overall model ranks of the chick survival anlaysis based on AIC weight
```{r, fig.height=9, fig.width=6, fig.align="center"}
Bootstrap_AIC_weight_plot_C <- 
  ggplot(aes(y = weight, x = p), data = chick_AIC_tables) + 
  theme_bw() +
  geom_boxplot(width = 0.3, fill = "grey70", outlier.size = 0.5) +
  theme(#text = element_text(family="Arial"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x  = element_text(size=10, angle = 45, hjust = 1), 
        axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
        axis.text.y  = element_text(size=10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        plot.margin = unit(c(0.5,0.5,0.5,0.3), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank()) +
  scale_y_continuous(limits=c(0,1)) +
  xlab("Model") + 
  ylab("AIC weight")

# jpeg(filename = "/Users/Luke/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/figs/final/final_final/AIC_multi_plot_chicks.jpeg",
#      quality = 100,
#      width = 6,
#      height = 9,
#      units = "in",
#      res = 300)

grid.newpage()
pushViewport(viewport(layout = grid.layout(5, 1)))
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
print(Bootstrap_Delta_AIC_plot_C, vp = vplayout(1:2, 1))  # key is to define vplayout
print(Bootstrap_AIC_weight_plot_C, vp = vplayout(3:5, 1))
# dev.off()
```
plot the overall model ranks of the fledgling and adult survival anlaysis based on Delta AIC
```{r, fig.height=5, fig.width=6, fig.align="center"}
Bootstrap_Delta_AIC_plot_F_A <- 
  ggplot(aes(y = DeltaAICc, x = p), data = fldg_ad_AIC_tables) + 
  theme_bw() +
  #geom_violin(fill = "grey40") +
  geom_boxplot(width = 0.3, fill = "grey70", outlier.size = 0.5) +
  theme(#text = element_text(family="Arial"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x  = element_blank(), 
        axis.title.y = element_text(size=12, margin = margin(0, 18, 0, 0)),
        axis.text.y  = element_text(size=10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        plot.margin = unit(c(0.5,0.5,0,0.8), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank()) +
  scale_y_continuous(limits=c(0,50)) +
  xlab("Model") + 
  ylab("Delta AIC") +
  #ylab("\u0394 AIC") +
  ggtitle("Fledgling and adult resighting model selection")
```
plot the overall model ranks of the fledgling and adult survival anlaysis based on AIC weight
```{r, fig.height=9, fig.width=6, fig.align="center"}
Bootstrap_AIC_weight_plot_F_A <- 
  ggplot(aes(y = weight, x = p), data = fldg_ad_AIC_tables) + 
  theme_bw() +
  geom_boxplot(width = 0.3, fill = "grey70", outlier.size = 0.5) +
  theme(#text = element_text(family="Arial"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x  = element_text(size=10, angle = 45, hjust = 1), 
        axis.title.y = element_text(size=12, margin = margin(0, 18, 0, 0)),
        axis.text.y  = element_text(size=10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank(),
        plot.background = element_rect(fill = "transparent",colour = NA)) +
  scale_y_continuous(limits=c(0,1)) +
  xlab("Model") + 
  ylab("AIC weight")

# jpeg(filename = "/Users/Luke/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/figs/final/final_final/AIC_multi_plot_fledgling_adult.jpeg",
#      quality = 100,
#      width = 6,
#      height = 9,
#      units = "in",
#      res = 300)

grid.newpage()
pushViewport(viewport(layout = grid.layout(5, 1)))
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
print(Bootstrap_Delta_AIC_plot_F_A, vp = vplayout(1:2, 1))  # key is to define vplayout
print(Bootstrap_AIC_weight_plot_F_A, vp = vplayout(3:5, 1))
# dev.off()
```

***
## Life table response experiment

Perturbation analyses provide important information about the relative contribution that each component of a matrix model has on the response, in our case ASR. To assess how influential a sex-bias in each of the three life-stages is on ASR dynamics, we employed a life-table response experiment (LTRE). In essence, the LTRE compares the response of a “control” matrix to that of a “treatment” matrix and assesses the relative contribution that model components have on the effect size of the treatment.

The following two functions need to be specified first:

**sensitivity_analysis()** determines the sensitivities of each parameter in the non-linear two-sex matrix model. It does this by perturbing each parameter independently and simulating the matrix until the stable stage is achieved and the ASR or lambda can be determined. After all perturbations have been tested, a spline of the response vs. perturbated values is found and the tangent of this spline at the observed parameter value is defined as a given parameter's sensitivity.
```{r}
sensitivity_analysis <-
  function(vital_rates, matrix_str, h = 1, k = 3, HSR, niter = 1000, ASR, lambda){
    
    # make a list of all parameters
    vr <-
      list(F_Chk_survl = vital_rates$F_Chk_survl,
           F_Fdg_survl = vital_rates$F_Fdg_survl,
           F_Adt_survl = vital_rates$F_Adt_survl,
           M_Chk_survl = vital_rates$M_Chk_survl,
           M_Fdg_survl = vital_rates$M_Fdg_survl,
           M_Adt_survl = vital_rates$M_Adt_survl)

    # number of stages in the matrix
    no_stages <- sqrt(length(matrix_str))

    # Define plover life-stages of the Ceuta snowy plover matrix model
    stages <- c("F_1st_yr",  "F_Adt",  "M_1st_yr",  "M_Adt")

    # an empty t by x matrix
    stage <- matrix(numeric(no_stages * niter), nrow = no_stages)

    # an empty t vector to store the population sizes
    pop <- numeric(niter)

    # dataframe to store the perturbation results
    ASR_pert_results <-
      data.frame(parameter = c("F_Chk_survl", "F_Fdg_survl", "F_Adt_survl",
                               "M_Chk_survl", "M_Fdg_survl", "M_Adt_survl",
                               "h", "k", "HSR"),
                 sensitivities = numeric(9),
                 elasticities = numeric(9))

    lambda_pert_results <-
      data.frame(parameter = c("F_Chk_survl", "F_Fdg_survl", "F_Adt_survl",
                               "M_Chk_survl", "M_Fdg_survl", "M_Adt_survl",
                               "h", "k", "HSR"),
                 sensitivities = numeric(9),
                 elasticities = numeric(9))

    # specifiy how many survival rates there are
    n <- length(vr)

    # create vectors of perturbations to test on parameters of the matrix model
    vr_nums <- seq(0, 1, 0.01) # proportional changes in survival and HSR (i.e., between 0 an 1)
    h_nums <- seq(0, 2, 0.02) # proportional changes in h index (i.e., between 0 and 2)
    k_nums <- seq(2, 4, 0.02) # proportional changes in k (i.e, between 2 and 4)

    # create empty dataframes to store the perturbation results for ASR and lambda
    vr_pert_ASR <- matrix(numeric(n * length(vr_nums)),
                      ncol = n, dimnames = list(vr_nums, names(vr)))
    h_pert_ASR <- matrix(numeric(length(h_nums)),
                     ncol = 1, dimnames = list(h_nums, "h"))
    k_pert_ASR <- matrix(numeric(length(k_nums)),
                     ncol = 1, dimnames = list(k_nums, "k"))
    HSR_pert_ASR <- matrix(numeric(length(vr_nums)),
                       ncol = 1, dimnames = list(vr_nums, "HSR"))
    vr_pert_lambda <- matrix(numeric(n * length(vr_nums)),
                          ncol = n, dimnames = list(vr_nums, names(vr)))
    h_pert_lambda <- matrix(numeric(length(h_nums)),
                         ncol = 1, dimnames = list(h_nums, "h"))
    k_pert_lambda <- matrix(numeric(length(k_nums)),
                         ncol = 1, dimnames = list(k_nums, "k"))
    HSR_pert_lambda <- matrix(numeric(length(vr_nums)),
                           ncol = 1, dimnames = list(vr_nums, "HSR"))

    # perturbation of vital rates survival rates
    for (g in 1:n) # pick a column (i.e., a variable)
    {
      vr2 <- vr # reset the vital rates to the original
      for (i in 1:length(vr_nums)) # pick a perturbation level
      {
        vr2[[g]] <- vr_nums[i] # specify the vital rate with the new perturbation level
        A <- matrix(sapply(matrix_str, eval, vr2, NULL), 
                    nrow = sqrt(length(matrix_str)), byrow=TRUE, 
                    dimnames = list(stages, stages)) # build the matrix with the new value
        m <- rep(10, no_stages) # reset the starting stage distribution for simulation (all with 10 individuals)
        for (j in 1:niter) { # project the matrix through t iteration
          # stage distribution at time t
          stage[,j] <- m
          # population size at time t
          pop[j] <- sum(m)
          # number of male adults at time t
          M2 <- stage[4, j]
          # number of female adults at time t
          F2 <- stage[2, j]
          # Female freq-dep fecundity of Female chicks
          A[1,no_stages/2]        <- ((k*M2)/(M2+(F2/h)))*HSR
          # Female freq-dep fecundity of Male chicks
          A[(no_stages/4)*3,no_stages/2]  <- ((k*M2)/(M2+(F2/h)))*HSR
          # Male freq-dep fecundity of Female chicks
          A[1,no_stages]          <- ((k*F2)/(M2+(F2/h)))*HSR
          # Male freq-dep fecundity of Male chicks
          A[(no_stages/4)*3,no_stages]    <- ((k*F2)/(M2+(F2/h)))*HSR
          # define the new n (i.e., new stage distribution at time t)
          m <- A %*% m
        }
        # define rownames of stage matrix
        rownames(stage) <- rownames(A)
        # define colnames of stage matrix
        colnames(stage) <- 0:(niter - 1)
        # calculate the proportional stable stage distribution
        stage <- apply(stage, 2, function(x) x/sum(x))
        # define stable stage as the last stage
        stable.stage <- stage[, niter]
        # calc ASR as the proportion of the adult stable stage class that is male
        vr_pert_ASR[i, g] <- stable.stage[no_stages]/(stable.stage[no_stages/2] + 
                                                        stable.stage[no_stages])
        # calc lambda as the pop change in the counts of the last two iterations
        vr_pert_lambda[i, g] <- pop[niter]/pop[niter - 1]
      }
      spl_ASR <- smooth.spline(vr_pert_ASR[,g] ~ rownames(vr_pert_ASR))
      ASR_pert_results[g, 2] <- predict(spl_ASR, x=vr[[g]], deriv=1)$y
      ASR_pert_results[g, 3] <- vr[[g]]/ASR * ASR_pert_results[g, 2]

      spl_lambda <- smooth.spline(vr_pert_lambda[,g] ~ rownames(vr_pert_lambda))
      lambda_pert_results[g, 2] <- predict(spl_lambda, x=vr[[g]], deriv=1)$y
      lambda_pert_results[g, 3] <- vr[[g]]/lambda * lambda_pert_results[g, 2]
    }
    # perturbation of the h index parameter
    for (i in 1:length(h_nums)) # pick a perturbation level
    {
      A <- matrix(sapply(matrix_str, eval, vr, NULL), 
                  nrow = sqrt(length(matrix_str)), byrow=TRUE, 
                  dimnames = list(stages, stages)) # build the matrix with the new value
      m <- rep(10, no_stages) # reset the starting stage distribution for simulation (all with 10 individuals)
      for (j in 1:niter) { # project the matrix through t iteration
        # stage distribution at time t
        stage[,j] <- m
        # population size at time t
        pop[j] <- sum(m)
        # number of male adults at time t
        M2 <- stage[4, j]
        # number of female adults at time t
        F2 <- stage[2, j]
        # Female freq-dep fecundity of Female chicks
        A[1,no_stages/2]        <- ((k*M2)/(M2+(F2/h_nums[i])))*HSR
        # Female freq-dep fecundity of Male chicks
        A[(no_stages/4)*3,no_stages/2] <- ((k*M2)/(M2+(F2/h_nums[i])))*HSR
        # Male freq-dep fecundity of Female chicks
        A[1,no_stages]          <- ((k*F2)/(M2+(F2/h_nums[i])))*HSR
        # Male freq-dep fecundity of Male chicks
        A[(no_stages/4)*3,no_stages] <- ((k*F2)/(M2+(F2/h_nums[i])))*HSR
        # define the new n (i.e., new stage distribution at time t)
        m <- A %*% m
      }
      # define rownames of stage matrix
      rownames(stage) <- rownames(A)
      # define colnames of stage matrix
      colnames(stage) <- 0:(niter - 1)
      # calculate the proportional stable stage distribution
      stage <- apply(stage, 2, function(x) x/sum(x))
      # define stable stage as the last stage
      stable.stage <- stage[, niter]
      # calc ASR as the proportion of the adult stable stage class that is male
      h_pert_ASR[i,] <- stable.stage[no_stages]/(stable.stage[no_stages/2] + stable.stage[no_stages])
      # calc lambda as the pop change in the counts of the last two iterations
      h_pert_lambda[i, ] <- pop[niter]/pop[niter - 1]
    }
    spl_ASR <- smooth.spline(h_pert_ASR[, 1] ~ rownames(h_pert_ASR))
    ASR_pert_results[n+1, 2] <- predict(spl_ASR, x=h, deriv=1)$y
    ASR_pert_results[n+1, 3] <- h/ASR * ASR_pert_results[n+1, 2]

    spl_lambda <- smooth.spline(h_pert_lambda[,1] ~ rownames(h_pert_lambda))
    lambda_pert_results[n+1, 2] <- predict(spl_lambda, x=h, deriv=1)$y
    lambda_pert_results[n+1, 3] <- h/lambda * lambda_pert_results[n+1, 2]

    # perturbation of k parameter
    for (i in 1:length(k_nums)) # pick a perturbation level
    {
      A <- matrix(sapply(matrix_str, eval, vr, NULL), 
                  nrow = sqrt(length(matrix_str)), byrow=TRUE, 
                  dimnames = list(stages, stages)) # build the matrix with the new value
      m <- rep(10, no_stages) # reset the starting stage distribution for simulation (all with 10 individuals)
      for (j in 1:niter) { # project the matrix through t iteration
        # stage distribution at time t
        stage[,j] <- m
        # population size at time t
        pop[j] <- sum(m)
        # number of male adults at time t
        M2 <- stage[4, j]
        # number of female adults at time t
        F2 <- stage[2, j]
        # Female freq-dep fecundity of Female chicks
        A[1,no_stages/2]        <- ((k_nums[i]*M2)/(M2+(F2/h)))*HSR
        # Female freq-dep fecundity of Male chicks
        A[(no_stages/4)*3,no_stages/2] <- ((k_nums[i]*M2)/(M2+(F2/h)))*HSR
        # Male freq-dep fecundity of Female chicks
        A[1,no_stages]          <- ((k_nums[i]*F2)/(M2+(F2/h)))*HSR
        # Male freq-dep fecundity of Male chicks
        A[(no_stages/4)*3,no_stages] <- ((k_nums[i]*F2)/(M2+(F2/h)))*HSR
        # define the new n (i.e., new stage distribution at time t)
        m <- A %*% m
      }
      # define rownames of stage matrix
      rownames(stage) <- rownames(A)
      # define colnames of stage matrix
      colnames(stage) <- 0:(niter - 1)
      # calculate the proportional stable stage distribution
      stage <- apply(stage, 2, function(x) x/sum(x))
      # define stable stage as the last stage
      stable.stage <- stage[, niter]
      # calc ASR as the proportion of the adult stable stage class that is male
      k_pert_ASR[i,] <- stable.stage[no_stages]/(stable.stage[no_stages/2] + 
                                                   stable.stage[no_stages])
      # calc lambda as the pop change in the counts of the last two iterations
      k_pert_lambda[i, ] <- pop[niter]/pop[niter - 1]
    }
    spl_ASR <- smooth.spline(k_pert_ASR[,1] ~ rownames(k_pert_ASR))
    ASR_pert_results[n+2, 2] <- predict(spl_ASR, x=k, deriv=1)$y
    ASR_pert_results[n+2, 3] <- k/ASR * ASR_pert_results[n+2, 2]

    spl_lambda <- smooth.spline(k_pert_lambda[,1] ~ rownames(k_pert_lambda))
    lambda_pert_results[n+2, 2] <- predict(spl_lambda, x=k, deriv=1)$y
    lambda_pert_results[n+2, 3] <- k/lambda * lambda_pert_results[n+2, 2]
    # perturbation of HSR
    for (i in 1:length(vr_nums)) # pick a perturbation level
    {
      A <- matrix(sapply(matrix_str, eval, vr, NULL), 
                  nrow = sqrt(length(matrix_str)), byrow=TRUE, 
                  dimnames = list(stages, stages)) # build the matrix with the new value
      m <- rep(10, no_stages) # reset the starting stage distribution for simulation (all with 10 individuals)
      for (j in 1:niter) { # project the matrix through t iteration
        # stage distribution at time t
        stage[,j] <- m
        # population size at time t
        pop[j] <- sum(m)
        # number of male adults at time t
        M2 <- stage[4, j]
        # number of female adults at time t
        F2 <- stage[2, j]
        # Female freq-dep fecundity of Female chicks
        A[1,no_stages/2]        <- ((k*M2)/(M2+(F2/h)))*vr_nums[i]
        # Female freq-dep fecundity of Male chicks
        A[(no_stages/4)*3,no_stages/2] <- ((k*M2)/(M2+(F2/h)))*vr_nums[i]
        # Male freq-dep fecundity of Female chicks
        A[1,no_stages]          <- ((k*F2)/(M2+(F2/h)))*vr_nums[i]
        # Male freq-dep fecundity of Male chicks
        A[(no_stages/4)*3,no_stages] <- ((k*F2)/(M2+(F2/h)))*vr_nums[i]
        # define the new n (i.e., new stage distribution at time t)
        m <- A %*% m
      }
      # define rownames of stage matrix
      rownames(stage) <- rownames(A)
      # define colnames of stage matrix
      colnames(stage) <- 0:(niter - 1)
      # calculate the proportional stable stage distribution
      stage <- apply(stage, 2, function(x) x/sum(x))
      # define stable stage as the last stage
      stable.stage <- stage[, niter]
      # calc ASR as the proportion of the adult stable stage class that is male
      HSR_pert_ASR[i,] <- stable.stage[no_stages]/(stable.stage[no_stages/2] + 
                                                     stable.stage[no_stages])
      # calc lambda as the pop change in the counts of the last two iterations
      HSR_pert_lambda[i, ] <- pop[niter]/pop[niter - 1]
    }
    spl_ASR <- smooth.spline(HSR_pert_ASR[,1] ~ rownames(HSR_pert_ASR))
    ASR_pert_results[n+3, 2] <- predict(spl_ASR, x=HSR, deriv=1)$y
    ASR_pert_results[n+3, 3] <- HSR/ASR * ASR_pert_results[n+3, 2]

    spl_lambda <- smooth.spline(HSR_pert_lambda[,1] ~ rownames(HSR_pert_lambda))
    lambda_pert_results[n+3, 2] <- predict(spl_lambda, x=HSR, deriv=1)$y
    lambda_pert_results[n+3, 3] <- HSR/lambda * lambda_pert_results[n+3, 2]

    result <- list(ASR_pert_results = ASR_pert_results,
                   lambda_pert_results = lambda_pert_results)
  }
```
**LTRE_analysis()** estimates the contribution that each vital rate has on ASR bias, given the sensitivities calculated in the previous function (see formula 8 on page 133 of Veran and Beissinger (2009))
```{r}
LTRE_analysis <-
  function(Mprime_sens, matrix_str, vital_rates){
    
    # make empty dataframes to stroe LTRE results for ASR and lambda
    LTRE_ASR <-
      data.frame(parameter = c("Chick survival", "Fledgling survival",
                               "Adult survival", "Hatching sex ratio",
                               "Mating system"),
                 contribution = numeric(5))

    LTRE_lambda <-
      data.frame(parameter = c("Chick survival", "Fledgling survival",
                               "Adult survival", "Hatching sex ratio",
                               "Mating system"),
                 contribution = numeric(5))

    # run a for loop to extract the parameter contributions
    for(i in 1:nrow(LTRE_ASR))
    {
      LTRE_ASR[i, 2] <-
        ifelse(i < 4, (vital_rates[[i + 3]] - vital_rates[[i]]) * 
                 Mprime_sens$ASR_pert_results$sensitivities[i + 3],
               ifelse(i == 4, ((1-vital_rates[[9]]) - vital_rates[[9]]) * 
                        Mprime_sens$ASR_pert_results$sensitivities[9],
                      (1 - vital_rates[[7]]) * Mprime_sens$ASR_pert_results$sensitivities[7]))
    }

    for(i in 1:nrow(LTRE_lambda))
    {
      LTRE_lambda[i, 2] <-
        ifelse(i < 4, (vital_rates[[i + 3]] - vital_rates[[i]]) * 
                 Mprime_sens$lambda_pert_results$sensitivities[i + 3],
               ifelse(i == 4, (vital_rates[[9]] - (1-vital_rates[[9]])) * 
                        Mprime_sens$lambda_pert_results$sensitivities[9],
                      (vital_rates[[7]] - 1) * Mprime_sens$lambda_pert_results$sensitivities[7]))
    }

    LTRE_ASR$parameter <- factor(LTRE_ASR$parameter, levels = c("Adult survival",
                                                                "Fledgling survival",
                                                                "Chick survival",
                                                                "Hatching sex ratio",
                                                                "Mating system"))

    LTRE_lambda$parameter <- factor(LTRE_lambda$parameter, levels = c("Adult survival",
                                                                      "Fledgling survival",
                                                                      "Chick survival",
                                                                      "Hatching sex ratio",
                                                                      "Mating system"))

    LTRE_results <- list(LTRE_ASR = LTRE_ASR,
                         LTRE_lambda = LTRE_lambda)
  }
```
define the iterations variable as a factor
```{r}
survival_rates_boot$iter <- as.factor(survival_rates_boot$iter)
```
summarise the bootstrap stage- and sex-specific survival rates for the deterministic matrix
```{r}
survival_rates_boot_summary <-
  Rmisc::summarySE(survival_rates_boot,
                   measurevar = "estimate",
                   groupvars = c("sex_age"),
                   conf.interval = 0.95)
```
define deteriministic Ceuta vital rates estimated from mark-recapture analysis. This are the "treatment" rates observed in the field:
```{r}
VR_treat <- list(F_Chk_survl = survival_rates_boot_summary[2,3],
                 F_Fdg_survl = survival_rates_boot_summary[3,3],
                 F_Adt_survl = survival_rates_boot_summary[1,3],
                 M_Chk_survl = survival_rates_boot_summary[5,3],
                 M_Fdg_survl = survival_rates_boot_summary[6,3],
                 M_Adt_survl = survival_rates_boot_summary[4,3],
                 # Define h (harem size, h = 1 is monogamy) and k (clutch size)
                 h = h,
                 k = 3,
                 # Define primary sex ratio
                 HSR = HSR)
```
Define vital rates of the M prime matrix (i.e., average between a "control matrix" and the "treatment matrix"). The control matrix is a matrix in which the female vital rates are set to the male vital rates, and the treatment matrix is the matrix containing the sex-specific values estimated from the field (see formula 8 on page 133 of Veran and Beissinger (2009))
```{r}
VR_mprime <- list(F_Chk_survl = (survival_rates_boot_summary[2,3] +
                                   survival_rates_boot_summary[5,3])/2,
                  F_Fdg_survl = (survival_rates_boot_summary[3,3] +
                                   survival_rates_boot_summary[6,3])/2,
                  F_Adt_survl = (survival_rates_boot_summary[1,3] +
                                   survival_rates_boot_summary[4,3])/2,
                  M_Chk_survl = (survival_rates_boot_summary[5,3] +
                                   survival_rates_boot_summary[5,3])/2,
                  M_Fdg_survl = (survival_rates_boot_summary[6,3] +
                                   survival_rates_boot_summary[6,3])/2,
                  M_Adt_survl = (survival_rates_boot_summary[4,3] +
                                   survival_rates_boot_summary[4,3])/2,
                  # Define h (harem size, h = 1 is monogamy) and k (clutch size)
                  h = (h+1)/2,
                  k = 3,
                  # Define primary sex ratio
                  HSR = (HSR+0.5)/2)

VR_equal_mono <- list(F_Chk_survl = survival_rates_boot_summary[5,3],
                      F_Fdg_survl = survival_rates_boot_summary[6,3],
                      F_Adt_survl = survival_rates_boot_summary[4,3],
                      M_Chk_survl = survival_rates_boot_summary[5,3],
                      M_Fdg_survl = survival_rates_boot_summary[6,3],
                      M_Adt_survl = survival_rates_boot_summary[4,3],
                      # Define h (harem size, h = 1 is monogamy) and k (clutch size)
                      h = 1,
                      k = 3,
                      # Define primary sex ratio
                      HSR = 0.5)

VR_equal_poly <- list(F_Chk_survl = survival_rates_boot_summary[5,3],
                      F_Fdg_survl = survival_rates_boot_summary[6,3],
                      F_Adt_survl = survival_rates_boot_summary[4,3],
                      M_Chk_survl = survival_rates_boot_summary[5,3],
                      M_Fdg_survl = survival_rates_boot_summary[6,3],
                      M_Adt_survl = survival_rates_boot_summary[4,3],
                      # Define h (harem size, h = 1 is monogamy) and k (clutch size)
                      h = h,
                      k = 3,
                      # Define primary sex ratio
                      HSR = 0.5)

VR_diff_mono <- list(F_Chk_survl = survival_rates_boot_summary[2,3],
                     F_Fdg_survl = survival_rates_boot_summary[3,3],
                     F_Adt_survl = survival_rates_boot_summary[1,3],
                     M_Chk_survl = survival_rates_boot_summary[5,3],
                     M_Fdg_survl = survival_rates_boot_summary[6,3],
                     M_Adt_survl = survival_rates_boot_summary[4,3],
                     # Define h (harem size, h = 1 is monogamy) and k (clutch size)
                     h = 1,
                     k = 3,
                     # Define primary sex ratio
                     HSR = 0.5)
```
specify the struture of the matrix (i.e. show the lower-level element functions)
```{r}
matrix_structure <- expression(
                               # top row of matrix
                               0, NA, 0, NA,
                               
                               # second row of matrix
                               (F_Chk_survl * F_Fdg_survl), F_Adt_survl, 0, 0,
                               
                               # third row of matrix
                               0, NA, 0, NA,
                               
                               # fourth row of matrix
                               0, 0, (M_Chk_survl * M_Fdg_survl), M_Adt_survl
                               
                               )
```
build the treatment matrix
```{r}
treatment_matrix <- plover_matrix(VR_treat)
```
build the M-prime matrix
```{r}
M_prime_matrix <- plover_matrix(VR_mprime)

equal_mono_mat <- plover_matrix(VR_equal_mono)
equal_poly_mat <- plover_matrix(VR_equal_poly)
diff_mono_mat <- plover_matrix(VR_diff_mono)
```
determine the ASR at the stable stage distribution
```{r}
treatment_ASR_analysis <- 
  matrix_ASR(M = treatment_matrix, h = h, HSR = VR_treat$HSR, iterations = 1000)
ASR_treat <- treatment_ASR_analysis$ASR
ASR_treat

M_prime_ASR_analysis <- 
  matrix_ASR(M = M_prime_matrix, h = 1, HSR = VR_mprime$HSR, iterations = 1000)
ASR_mprime <- M_prime_ASR_analysis$ASR
ASR_mprime

equal_mono_ASR_analysis <- 
  matrix_ASR(M = equal_mono_mat, h = 1, HSR = 0.5, iterations = 1000)
ASR_equal_mono <- equal_mono_ASR_analysis$ASR
ASR_equal_mono

equal_poly_ASR_analysis <- 
  matrix_ASR(M = equal_poly_mat, h = h, HSR = 0.5, iterations = 1000)
ASR_equal_poly <- equal_poly_ASR_analysis$ASR
ASR_equal_poly

diff_mono_ASR_analysis <- 
  matrix_ASR(M = diff_mono_mat, h = 1, HSR = 0.5, iterations = 1000)
ASR_diff_mono <- diff_mono_ASR_analysis$ASR
ASR_diff_mono
```
specify the lambda of the matrices
```{r}
lambda_treat <- treatment_ASR_analysis$lambda
lambda_treat

lambda_mprime <- M_prime_ASR_analysis$lambda
lambda_mprime

lambda_equal_mono <- equal_mono_ASR_analysis$lambda
lambda_equal_mono

lambda_equal_poly <- equal_poly_ASR_analysis$lambda
lambda_equal_poly

lambda_diff_mono <- diff_mono_ASR_analysis$lambda
lambda_diff_mono
```
conduct a sensitivity analysis on the treatment matrix
```{r}
treat_sensitivity_analysis <- 
  sensitivity_analysis(vital_rates = VR_treat, 
                       matrix_str = matrix_structure, 
                       h = VR_treat$h, 
                       k = VR_treat$k, 
                       HSR = VR_treat$HSR, 
                       niter = 1000, 
                       ASR = ASR_treat,
                       lambda = lambda_treat)
```
conduct a sensitivity analysis on the M-Prime matrix
```{r}
Mprime_sensitivity_analysis <- 
  sensitivity_analysis(vital_rates = VR_mprime, 
                       matrix_str = matrix_structure, 
                       h = VR_mprime$h, 
                       k = VR_mprime$k, 
                       HSR = VR_mprime$HSR, 
                       niter = 1000, 
                       ASR = ASR_mprime,
                       lambda = lambda_mprime)

equal_mono_sensitivity_analysis <- 
  sensitivity_analysis(vital_rates = VR_equal_mono, 
                       matrix_str = matrix_structure, 
                       h = VR_equal_mono$h, 
                       k = VR_equal_mono$k, 
                       HSR = VR_equal_mono$HSR, 
                       niter = 1000, 
                       ASR = ASR_equal_mono,
                       lambda = lambda_equal_mono)

equal_poly_sensitivity_analysis <- 
  sensitivity_analysis(vital_rates = VR_equal_poly, 
                       matrix_str = matrix_structure, 
                       h = VR_equal_poly$h, 
                       k = VR_equal_poly$k, 
                       HSR = VR_equal_poly$HSR, 
                       niter = 1000, 
                       ASR = ASR_equal_poly,
                       lambda = lambda_equal_poly)

diff_mono_sensitivity_analysis <- 
  sensitivity_analysis(vital_rates = VR_diff_mono, 
                       matrix_str = matrix_structure, 
                       h = VR_diff_mono$h, 
                       k = VR_diff_mono$k, 
                       HSR = VR_diff_mono$HSR, 
                       niter = 1000, 
                       ASR = ASR_diff_mono,
                       lambda = lambda_diff_mono)
```
conduct the LTRE comparing the two matrices
```{r}
LTRE_plover <- 
  LTRE_analysis(Mprime_sens = Mprime_sensitivity_analysis, 
                matrix_str = matrix_str, 
                vital_rates = VR_treat)
```
custom color palette for the plotting of Fledgling and Adult stats
```{r}
cbPalette <- c("#A6A6A6", "#D9D9D9", "#D9D9D9", "#D9D9D9", "#A6A6A6")
```
plot the comparative LTRE results
```{r, fig.width=4, fig.height=5, fig.align="center"}
Background_LTRE_ASR <-
  ggplot2::ggplot(data = LTRE_plover$LTRE_ASR,
                  aes(x = parameter, y = contribution, fill = parameter)) +
  coord_flip() +
  theme_bw() +
  annotate("rect", xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=0, alpha=0.6,
           fill=brewer.pal(8, "Dark2")[c(2)]) +
  annotate("rect", xmin=-Inf, xmax=Inf, ymin=0, ymax=Inf, alpha=0.6,
           fill=brewer.pal(8, "Dark2")[c(1)]) +
  # annotate("text", x = c(2,2), y = c(-Inf, Inf),
  #          label = c("\u2640", "\u2642"), size = 7,
  #          family="Arial", vjust = c(0.5,0.5), hjust = c(-0.3,1.3)) +
  annotate("text", x = c(2,2), y = c(-0.1, 0.1),
           label = c("female", "male"), size = 7,
           vjust = c(1,1), hjust = c(0.5,0.5), angle = c(90, 270)) +
  theme(text = element_text(#family="Arial", 
                            color = "white"), # set the font as Candara
        legend.position = "none",
        axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
        axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)),
        axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
        axis.text.y  = element_text(size=10, angle = 0, hjust = 1, 
                                    margin = margin(0, 1, 0, 0)),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_line(size = 0.5, colour = "white"),
        axis.ticks.length = unit(0.2, "cm"),
        panel.border = element_blank(),
        plot.margin = unit(c(1,0.5,0.5,2.7), "cm"),
        # plot.margin = unit(c(1,0.5,0.5,2.3), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(),
        strip.text = element_blank()) +
  ylab("Contribution to adult sex ratio") +
  xlab("Sex-bias in parameter") +
  scale_fill_manual(values = cbPalette) +
  scale_y_continuous(limits = c(-0.1, 0.1)) +
  # scale_x_discrete(labels = c("Adult survival" = expression(Adult["\u03D5"]),
  #                             "Fledgling survival" = expression(Fledgling ["\u03D5"]),
  #                             "Chick survival" = expression(Chick ["\u03D5"]),
  #                             "Hatching sex ratio" = expression(italic("\u03C1")),
  #                             "Mating system" = expression(italic("h"))))
  scale_x_discrete(labels = c("Adult survival" = "Adult surv.",
                              "Fledgling survival" = "Fledg. surv",
                              "Chick survival" = "Chick surv.",
                              "Hatching sex ratio" = "Hatching SR",
                              "Mating system" = "Mat. sys."))

LTRE_ASR <-
  ggplot2::ggplot() +
  theme_bw() +
  coord_flip() +
  geom_bar(data = LTRE_plover$LTRE_ASR,
           aes(x = parameter, y = contribution, fill = parameter), color = "black", stat = "identity") +
  theme(#text = element_text(family="Arial"),
        legend.position = "none",
        panel.background = element_rect(fill = "transparent",colour = NA),
        plot.background = element_rect(fill = "transparent",colour = NA),
        axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
        axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)),
        axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
        axis.text.y  = element_text(size=10, angle = 0, hjust = 1, 
                                    margin = margin(0, 1, 0, 0)),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        panel.border = element_rect(linetype = "solid", colour = "grey"),
        plot.margin = unit(c(1,0.5,0.5,0.5), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(),
        strip.text = element_blank()) +
  ylab("Contribution to adult sex ratio") +
  xlab("Sex-bias in parameter") +
  scale_fill_manual(values = cbPalette) +
  scale_y_continuous(limits = c(-0.10, 0.10)) +
  # scale_x_discrete(labels = c("Adult survival" = expression(Adult["\u03D5"]),
  #                             "Fledgling survival" = expression(Fledgling ["\u03D5"]),
  #                             "Chick survival" = expression(Chick ["\u03D5"]),
  #                             "Hatching sex ratio" = expression(italic("\u03C1")),
  #                             "Mating system" = expression(italic("h")))) 
  scale_x_discrete(labels = c("Adult survival" = "Adult surv.",
                              "Fledgling survival" = "Fledg. surv",
                              "Chick survival" = "Chick surv.",
                              "Hatching sex ratio" = "Hatching SR",
                              "Mating system" = "Mat. sys."))
                     
# Save the plot
# jpeg(filename = "/Users/Luke/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/figs/final/final_final/LTRE_mating_function_ASR.jpeg",
#      quality = 100,
#      width = 4,
#      height = 5,
#      units = "in",
#      res = 300)

# draw the background and the LTRE on top of eachother for the final plot
grid.newpage()
pushViewport( viewport( layout = grid.layout( 1 , 1 , widths = unit( 1 , "npc" ) ) ) )
print( Background_LTRE_ASR + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
print( LTRE_ASR + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
# dev.off()
```
Determine how much larger the contribution of each vital rates is compared to fledgling survival
fledgling vs chick:
```{r}
LTRE_plover$LTRE_ASR[2,2]/LTRE_plover$LTRE_ASR[1,2]
```
fledgling vs adult:
```{r}
LTRE_plover$LTRE_ASR[2,2]/LTRE_plover$LTRE_ASR[3,2]
```
chick vs adult:
```{r}
LTRE_plover$LTRE_ASR[1,2]/LTRE_plover$LTRE_ASR[3,2]
```
prepare the lambda elasticities to plot
```{r}
equal_mono_sensitivity_analysis$lambda_pert_results$model <- "equal_mono"
equal_poly_sensitivity_analysis$lambda_pert_results$model <- "equal_poly"
diff_mono_sensitivity_analysis$lambda_pert_results$model <- "diff_mono"
treat_sensitivity_analysis$lambda_pert_results$model <- "diff_poly"
lambda_elasticities <- rbind(equal_mono_sensitivity_analysis$lambda_pert_results[-8,-2],
                             equal_poly_sensitivity_analysis$lambda_pert_results[-8,-2],
                             diff_mono_sensitivity_analysis$lambda_pert_results[-8,-2],
                             treat_sensitivity_analysis$lambda_pert_results[-8,-2])
lambda_elasticities$vital_rate <- 
  as.factor(c("Chick_survival", "Fledgling_survival", "Adult_survival", "Chick_survival", 
              "Fledgling_survival", "Adult_survival", "Mating_system", "Hatching_sex_ratio"))
lambda_elasticities$model <- factor(lambda_elasticities$model, 
                                         levels = c("diff_poly", "diff_mono", "equal_poly", "equal_mono"))
lambda_elasticities$vital_rate <- factor(lambda_elasticities$vital_rate, 
                                         levels = c("Adult_survival", "Fledgling_survival", 
                                                    "Chick_survival", "Hatching_sex_ratio", 
                                                    "Mating_system"))
lambda_elasticities$sex <- as.factor(c("Female", "Female", 
                                       "Female", "Male", 
                                       "Male", "Male", 
                                       "Female", "Female"))

lambda_elasticities$model_vital_rate <- as.factor(paste(lambda_elasticities$model, lambda_elasticities$vital_rate, sep = "_"))
lambda_elasticities$model_vital_rate <- factor(lambda_elasticities$model_vital_rate,
                                               levels = c("diff_poly_Adult_survival", "diff_poly_Fledgling_survival", "diff_poly_Chick_survival",
                                                          "diff_poly_Hatching_sex_ratio", "diff_poly_Mating_system",
                                                          "diff_mono_Adult_survival", "diff_mono_Fledgling_survival", "diff_mono_Chick_survival",
                                                          "diff_mono_Hatching_sex_ratio", "diff_mono_Mating_system",
                                                          "equal_poly_Adult_survival", "equal_poly_Fledgling_survival", "equal_poly_Chick_survival",
                                                          "equal_poly_Hatching_sex_ratio", "equal_poly_Mating_system",
                                                          "equal_mono_Adult_survival", "equal_mono_Fledgling_survival", "equal_mono_Chick_survival",
                                                          "equal_mono_Hatching_sex_ratio", "equal_mono_Mating_system"))


# lambda_elasticities <- 
#   treat_sensitivity_analysis$lambda_pert_results[-8,-2]
# lambda_elasticities$vital_rate <- 
#   as.factor(c("Chick survival", "Fledgling survival", "Adult survival", "Chick survival", 
#               "Fledgling survival", "Adult survival", "Mating system", "Hatching sex ratio"))
# lambda_elasticities$vital_rate <- factor(lambda_elasticities$vital_rate, 
#                                          levels = c("Adult survival", "Fledgling survival", 
#                                                     "Chick survival", "Hatching sex ratio", 
#                                                     "Mating system"))
# lambda_elasticities$sex <- as.factor(c("Female", "Female", 
#                                        "Female", "Male", 
#                                        "Male", "Male", 
#                                        "Female", "Female"))
```
plot the elasticities of lambda to perturbations of each parameter
```{r, fig.width=4, fig.height=8, fig.align="center"}
cbPalette <- c("#A6A6A6", "#D9D9D9", "#D9D9D9", "#D9D9D9", "#A6A6A6")

cbPalette <- c("#88c6b2", "#e8a47e")
custom_pal <- c("#4575b4", "#91bfdb", "#9E6BB1", "#7b3294")
Background_lambda_elasticity <-
  ggplot2::ggplot(data = lambda_elasticities,
                  aes(x = model_vital_rate, y = elasticities, fill = sex)) +
  coord_flip() +
  theme_bw() +
  annotate("rect", xmin=0, xmax=5.02, ymin=-Inf, ymax=Inf, alpha=0.6,
           fill=custom_pal[4]) +
  annotate("rect", xmin=5.02, xmax=9.98, ymin=-Inf, ymax=Inf, alpha=0.6,
           fill=custom_pal[3]) +
  annotate("rect", xmin=9.98, xmax=14.96, ymin=-Inf, ymax=Inf, alpha=0.6,
           fill=custom_pal[2]) +
  annotate("rect", xmin=14.96, xmax=20, ymin=-Inf, ymax=Inf, alpha=0.6,
           fill=custom_pal[1]) +
  # annotate("text", y = c(0.45,0.45,0.45,0.45), x = c(17.5, 12.5, 7.5, 2.5),
  #                  label = c("\u2640\u2642 ASR\nmonogamy",
  #                            "\u2640\u2642 ASR\npolyandry",
  #                            "\u2642\u2642 ASR\nmonogamy",
  #                            "\u2642\u2642 ASR\npolyandry"), size = 3.5,
  #                  hjust = c(0.5, 0.5, 0.5, 0.5), angle = c(270, 270, 270, 270)) +
  annotate("text", y = c(0.45,0.45,0.45,0.45), x = c(17.5, 12.5, 7.5, 2.5),
                   label = c("Even ASR\nmonogamy",
                             "Even ASR\npolyandry",
                             "Male-biased ASR\nmonogamy",
                             "Male-biased ASR\npolyandry"), size = 3.5,
                   hjust = c(0.5, 0.5, 0.5, 0.5), angle = c(270, 270, 270, 270)) +
  theme(text = element_text(#family="Arial", 
                            color = "white"),
        legend.position = "none",
        axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
        axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)),
        axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
        axis.text.y  = element_text(size=10, angle = 0, hjust = 1, margin = margin(0, 1, 0, 0)),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_line(size = 0.5, colour = "white"),
        axis.ticks.length = unit(0.2, "cm"),
        panel.border = element_blank(),
        plot.margin = unit(c(0.05,0.5,-0.5,2.1), "cm"),
        # plot.margin = unit(c(0.15,0.5,-0.35,1.7), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(),
        strip.text = element_blank()) +
  ylab("Elasticity of population growth") +
  # ylab("Elasticity of population growth (\u03BB)") +
  xlab("Sex-specific parameter") +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(limits = c(-0.5, 0.5))

lambda_elasticity <- 
  ggplot2::ggplot() +
          theme_bw() +
          coord_flip() +
          geom_bar(data = filter(lambda_elasticities, sex == "Female"),
                   aes(x = model_vital_rate, y = elasticities*-1, fill = sex), 
                   color = "black", stat = "identity", alpha = 1) +
          geom_bar(data = filter(lambda_elasticities, sex == "Male"),
                   aes(x = model_vital_rate, y = elasticities, fill = sex),
                   color = "black", stat = "identity", alpha = 1) +
          theme(#text = element_text(family="Arial"),
                legend.position = "none",
                panel.background = element_rect(fill = "transparent", colour = NA),
                plot.background = element_rect(fill = "transparent", colour = NA),
                axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
                axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)), 
                axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
                axis.text.y  = element_text(size=10, angle = 0, hjust = 1, 
                                            margin = margin(0, 1, 0, 0)),
                panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(),
                axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
                axis.ticks.length = unit(0.2, "cm"),
                axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
                panel.border = element_rect(linetype = "solid", colour = "grey"),
                plot.margin = unit(c(1,0.5,0.5,0.5), "cm"),
                panel.margin = unit(0.75, "lines"),
                strip.background = element_blank(), 
                strip.text = element_blank()) +
          # ylab("Elasticity of population growth (\u03BB)") +
          ylab("Elasticity of population growth") +
          xlab("Sex-specific parameter") +
          scale_fill_manual(values = cbPalette) +
          scale_y_continuous(limits = c(-0.5, 0.5)) +
          # scale_x_discrete(labels = c("diff_poly_Adult_survival" = expression(Adult["\u03D5"]),
          #                             "diff_poly_Fledgling_survival" = expression(Fledgling["\u03D5"]),
          #                             "diff_poly_Chick_survival" = expression(Chick["\u03D5"]),
          #                             "diff_poly_Hatching_sex_ratio" = expression(italic("\u03C1")),
          #                             "diff_poly_Mating_system" = expression(italic("h")),
          #                             "diff_mono_Adult_survival" = expression(Adult["\u03D5"]),
          #                             "diff_mono_Fledgling_survival" = expression(Fledgling["\u03D5"]),
          #                             "diff_mono_Chick_survival" = expression(Chick["\u03D5"]),
          #                             "diff_mono_Hatching_sex_ratio" = expression(italic("\u03C1")),
          #                             "diff_mono_Mating_system" = expression(italic("h")),
          #                             "equal_poly_Adult_survival" = expression(Adult["\u03D5"]),
          #                             "equal_poly_Fledgling_survival" = expression(Fledgling["\u03D5"]),
          #                             "equal_poly_Chick_survival" = expression(Chick["\u03D5"]),
          #                             "equal_poly_Hatching_sex_ratio" = expression(italic("\u03C1")),
          #                             "equal_poly_Mating_system" = expression(italic("h")),
          #                             "equal_mono_Adult_survival" = expression(Adult["\u03D5"]),
          #                             "equal_mono_Fledgling_survival" = expression(Fledgling["\u03D5"]),
          #                             "equal_mono_Chick_survival" = expression(Chick["\u03D5"]),
          #                             "equal_mono_Hatching_sex_ratio" = expression(italic("\u03C1")),
          #                             "equal_mono_Mating_system" = expression(italic("h"))))
          scale_x_discrete(labels = c("diff_poly_Adult_survival" = "Adult surv",
                                      "diff_poly_Fledgling_survival" = "Fledg. surv",
                                      "diff_poly_Chick_survival" = "Chick surv",
                                      "diff_poly_Hatching_sex_ratio" = "Hatching SR",
                                      "diff_poly_Mating_system" = "Mating sys.",
                                      "diff_mono_Adult_survival" = "Adult surv",
                                      "diff_mono_Fledgling_survival" = "Fledg. surv",
                                      "diff_mono_Chick_survival" = "Chick surv",
                                      "diff_mono_Hatching_sex_ratio" = "Hatching SR",
                                      "diff_mono_Mating_system" = "Mating sys.",
                                      "equal_poly_Adult_survival" = "Adult surv",
                                      "equal_poly_Fledgling_survival" = "Fledg. surv",
                                      "equal_poly_Chick_survival" = "Chick surv",
                                      "equal_poly_Hatching_sex_ratio" = "Hatching SR",
                                      "equal_poly_Mating_system" = "Mating sys.",
                                      "equal_mono_Adult_survival" = "Adult surv",
                                      "equal_mono_Fledgling_survival" = "Fledg. surv",
                                      "equal_mono_Chick_survival" = "Chick surv",
                                      "equal_mono_Hatching_sex_ratio" = "Hatching SR",
                                      "equal_mono_Mating_system" = "Mating sys."))

#Save the plot
# jpeg(filename = "/Users/Luke/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/figs/final/final_final/Elasticity_lambda.jpeg",
#      quality = 100,
#      width = 4,
#      height = 8,
#      units = "in",
#      res = 300)

grid.newpage()
pushViewport( viewport( layout = grid.layout( 1 , 1 , widths = unit( 1 , "npc" ) ) ) )
print( Background_lambda_elasticity + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
print( lambda_elasticity + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
# dev.off()
```

***
## Population growth
```{r}
annual_survival_analysis <- function(){
# remove ring column
fledgling_adult <- fledgling_adult[,-1]
chick <- chick[,-1]

# Create processed RMark data formatted as Cormack-Jolly_Seber with 2 groups 
# (sex and age initally ringed), starting at year 2006, two age groups
# (first-years and adults) in which the first-year stage only lasts for 
# one year.
fledgling_adult.proc <- RMark::process.data(fledgling_adult, model = "CJS",
                                            groups = c("sex", "age"),
                                            begin.time = 2006, age.var = 2, 
                                            initial.age = c(1, 0))

# Create processed RMARK data format as Cormack-Jolly_Seber with 3 groups 
# (sex, year, and brood ID).
chick.proc <-  RMark::process.data(chick, model = "CJS",
                                   groups = c("sex", "year", 
                                              "brood_ID"))

# Create the design matrix from the processed mark-recapture datasets
fledgling_adult.ddl <- RMark::make.design.data(fledgling_adult.proc)
chick.ddl <- RMark::make.design.data(chick.proc)

# adds first-year / adult age field to design data in column "Age"
fledgling_adult.ddl <- RMark::add.design.data(data = fledgling_adult.proc,
                                              ddl = fledgling_adult.ddl, 
                                              parameter = "Phi", 
                                              type = "age",
                                              bins = c(0, 1, 7), right = FALSE,
                                              name = "age", replace = TRUE)

# create a dummy field in the design matrix called marked.as.adult 
# which is "0" for the group initally ringed as chicks and "1" for the group
# marked as adults.
fledgling_adult.ddl$Phi$marked.as.adult = 0
fledgling_adult.ddl$Phi$marked.as.adult[fledgling_adult.ddl$Phi$initial.age.class=="A"]=1 
fledgling_adult.ddl$p$marked.as.adult = 0
fledgling_adult.ddl$p$marked.as.adult[fledgling_adult.ddl$p$initial.age.class=="A"]=1

# check parameter matrices to see if groups were binned correctly 
# (uncomment the next three lines to assess)
# PIMS(mark(fledgling_adult.proc, fledgling_adult.ddl,
#           model.parameters = list(Phi = list(formula = ~ age + sex)), 
#           output = F), "Phi")

# Create quadratic time variable so that it can be tested for temporal variation 
# chick survival (i.e. non-linear relationship between daily chick survival and age)
time <- c(0:(chick.proc$nocc[1] - 1))
quadratic <- time^2
quad_time <- data.frame(time, quadratic)
chick.ddl$p <- 
  RMark::merge_design.covariates(chick.ddl$Phi,
                                 quad_time, bygroup = FALSE, bytime = TRUE)
chick.ddl$Phi <- 
  RMark::merge_design.covariates(chick.ddl$Phi,
                                 quad_time, bygroup = FALSE, bytime = TRUE)

# create the function that specifies the candidate models of fledgling and adult 
# resight probability
fledgling_adult_survival_year_sex_age = function() 
{
  # sex- and stage-specific survival varying across years ("Time"):
  Phi.agexsex_Time = list(formula = ~ age * sex + Time) 
  
  # Models exploring variation in encounter probability
  # constant:
  p.dot = list(formula =  ~ 1)
  # sex-dependent:
  p.sex = list(formula =  ~ sex)
  # age-dependent:
  p.age = list(formula =  ~ age)
  # factorial variation across year:
  p.Time = list(formula =  ~ Time)
  # interaction between sex and factorial year:
  p.sexxTime = list(formula =  ~ sex * Time)
  # interaction between age and factorial year:
  p.agexTime = list(formula =  ~ age * Time)
  # interaction between age and sex:
  p.agexsex = list(formula =  ~ age * sex)
  # additive effects of sex and factorial year:
  p.sex_Time = list(formula =  ~ sex + Time)
  # additive effects of age and factorial year:
  p.age_Time = list(formula =  ~ age + Time)
  # additive effects of age and sex:
  p.age_sex = list(formula =  ~ age + sex)
  # additive effects of sex, age, factorial year:
  p.Time_age_sex = list(formula =  ~ Time + age + sex)
  # additive effect of year and interaction between age and sex:
  p.Time_age_x_sex = list(formula =  ~ Time + age * sex)
  
  # create a list of candidate models for all the a models above that begin with 
  # either "Phi." or "p."
  cml <-  RMark::create.model.list("CJS")
  
  # specify the data, design matrix, delete unneeded output files, and 
  # run the models in Program MARK
  model.list <-  RMark::mark.wrapper(cml, data = fledgling_adult.proc, 
                                     ddl = fledgling_adult.ddl, delete = TRUE)
  
  # output the model list and sotre the results
  return(model.list)
}

# Run the models on the bootstrapped data
fledgling_adult_survival_year_sex_age_run <- 
  fledgling_adult_survival_year_sex_age()

# Extract the AIC model table from the model output
AIC_table_fledgling_adult <- 
  fledgling_adult_survival_year_sex_age_run$model.table

# Find the model number for the first ranked model of the AIC table
model_fledgling_adult_num <- 
  as.numeric(rownames(fledgling_adult_survival_year_sex_age_run$model.table[1,]))

# extract and format survival rates from fledgling and adult model output
fledgling_adult_reals <- 
  fledgling_adult_survival_year_sex_age_run[[model_fledgling_adult_num]]$results$real

# format the output to tidy up the sex-, age-, and year-specific effects
Groups <- data.frame(str_split_fixed(rownames(fledgling_adult_reals), " ", n = 5))
fledgling_adult_reals <- cbind(Groups, fledgling_adult_reals)
fledgling_adult_reals <- 
  fledgling_adult_reals[which(fledgling_adult_reals$X1 == "Phi"),]
fledgling_adult_reals$age <- 
  unlist(str_extract_all(fledgling_adult_reals$X2,"[AJ]"))
fledgling_adult_reals$age <- 
  as.factor(ifelse(fledgling_adult_reals$age == "A","Adult","Fledgling"))
fledgling_adult_reals$sex <- 
  unlist(str_extract_all(fledgling_adult_reals$X2,"[FM]"))
fledgling_adult_reals$sex <- 
  as.factor(ifelse(fledgling_adult_reals$sex == "F","Female","Male"))
fledgling_adult_reals$year <-
  as.factor(str_sub(fledgling_adult_reals$X5, 2, 5))
fledgling_adult_reals$sex_age <- 
  paste(fledgling_adult_reals$sex,fledgling_adult_reals$age,sep = "_")
fledgling_adult_survival_real <- 
  fledgling_adult_reals[,c("year", "sex_age", "estimate")]
row.names(fledgling_adult_survival_real) <- NULL

# Do the same for chicks. create the function that specifies the candidate models 
# of chick resight probability
chick_survival_year_sex_age = function() 
{
  # sex- and stage-specific survival varying across years ("Time"):
  Phi.quadratic.x.sex = list(formula = ~ sex * quadratic + year)
  
  # Models exploring variation in encounter probability
  # constant:
  p.dot = list(formula = ~ 1)
  # quadratic across age
  p.quadratic = list(formula = ~ quadratic)
  # annual variation
  p.year = list(formula = ~ year)
  # sex-specific
  p.sex = list(formula = ~ sex)
  # interaction between year and quadratic age
  p.year.x.quadratic = list(formula = ~ year * quadratic)
  # interaction between year and quadratic age
  p.sex.x.quadratic = list(formula = ~ sex * quadratic)
  # additive effects of sex and linear age
  p.sex.quadratic = list(formula = ~ sex + quadratic)
  # additive effects of year and quadratic age
  p.year.quadratic = list(formula = ~ year + quadratic)
  # additive effects of year, sex, and quadratic age
  p.year.quadratic.Sex = list(formula = ~ year + quadratic + sex)
  # additive effect of year and interaction between sex and quadratic age
  p.year.quadratic.x.Sex = list(formula = ~ year + quadratic * sex)
  
  # create a list of candidate models for all the a models above that begin with 
  # either "Phi." or "p."
  cml <-  RMark::create.model.list("CJS")
  
  # specify the data, design matrix, delete unneeded output files, and 
  # run the models in Program MARK
  model.list <-  RMark::mark.wrapper(cml, data = chick.proc, 
                                     ddl = chick.ddl, delete = TRUE)
  
  # output the model list and sotre the results
  return(model.list)
}

# Run the models on the bootstrapped data
chick_survival_year_sex_age_run <- chick_survival_year_sex_age()

# Extract the AIC model table from the model output
AIC_table_chick <- chick_survival_year_sex_age_run$model.table

# Find the model number for the first ranked model of the AIC table
model_chick_num <- as.numeric(rownames(chick_survival_year_sex_age_run$model.table[1,]))

# extract real parameter estimates from top models
chick_reals <- chick_survival_year_sex_age_run[[model_chick_num]]$results$real

# format the output to tidy up the sex-, age-, and year-specific effects
Groups <- data.frame(str_split_fixed(rownames(chick_reals), " ", n = 5))
chick_reals <- cbind(Groups, chick_reals)
chick_reals <- chick_reals[which(chick_reals$X1 == "Phi"),]
chick_reals$sex <- unlist(str_extract_all(chick_reals$X2,"[FM]"))
chick_reals$sex <- as.factor(ifelse(chick_reals$sex == "F","Female","Male"))
chick_reals$year <-
  as.factor(str_sub(chick_reals$X2, 3, 6))

# transform the daily chick survival (DCS) to apparent hatching success
# by calculating the product of all DCS estimates:
chick_survival_real <- 
  chick_reals%>%
  dplyr::group_by(year, sex)%>%
  dplyr::summarise(estimate = prod(estimate))
chick_survival_real$sex_age <- paste(chick_survival_real$sex, "Chick", sep = "_")

# Bind the fledgling and adult dataframe with the chicks
survival_rates_year_age_sex <- rbind(fledgling_adult_survival_real, ungroup(chick_survival_real)[,c(1,4,3)])

# Now do the survival analysis without sex (for the one-sex matrix model)
# create the function that specifies the candidate models of fledgling and adult 
# resight probability
fledgling_adult_survival_year_age = function() 
{
  # year- and stage-specific survival:
  Phi.agexsex_Time = list(formula = ~ age + Time) 
  
  # Models exploring variation in encounter probability
  # constant:
  p.dot = list(formula =  ~ 1)
  # age-dependent:
  p.age = list(formula =  ~ age)
  # factorial variation across year:
  p.Time = list(formula =  ~ Time)
  # interaction between age and factorial year:
  p.agexTime = list(formula =  ~ age * Time)
  # additive effects of age and factorial year:
  p.age_Time = list(formula =  ~ age + Time)

  # create a list of candidate models for all the a models above that begin with 
  # either "Phi." or "p."
  cml <-  RMark::create.model.list("CJS")
  
  # specify the data, design matrix, delete unneeded output files, and 
  # run the models in Program MARK
  model.list <-  RMark::mark.wrapper(cml, data = fledgling_adult.proc, 
                                     ddl = fledgling_adult.ddl, delete = TRUE)
  
  # output the model list and sotre the results
  return(model.list)
}

# Run the models on the bootstrapped data
fledgling_adult_survival_year_age_run <- 
  fledgling_adult_survival_year_age()

# Extract the AIC model table from the model output
AIC_table_fledgling_adult <- 
  fledgling_adult_survival_year_age_run$model.table

# Find the model number for the first ranked model of the AIC table
model_fledgling_adult_num <- 
  as.numeric(rownames(fledgling_adult_survival_year_age_run$model.table[1,]))

# extract and format survival rates from fledgling and adult model output
fledgling_adult_reals <- 
  fledgling_adult_survival_year_age_run[[model_fledgling_adult_num]]$results$real

# format the output to tidy up the sex- and age-specific effects
Groups <- data.frame(str_split_fixed(rownames(fledgling_adult_reals), " ", n = 5))
fledgling_adult_reals <- cbind(Groups, fledgling_adult_reals)
fledgling_adult_reals <- 
  fledgling_adult_reals[which(fledgling_adult_reals$X1 == "Phi"),]
fledgling_adult_reals$age <- 
  unlist(str_extract_all(fledgling_adult_reals$X2,"[AJ]"))
fledgling_adult_reals$age <- 
  as.factor(ifelse(fledgling_adult_reals$age == "A","Adult","Fledgling"))
fledgling_adult_reals$year <-
  as.factor(str_sub(fledgling_adult_reals$X5, 2, 5))
fledgling_adult_survival_real <- 
  fledgling_adult_reals[,c("year", "age", "estimate")]
row.names(fledgling_adult_survival_real) <- NULL

# Do the same for chicks. create the function that specifies the candidate models 
# of chick resight probability
chick_survival_year_age = function() 
{
  # year- and quadratic age-specific survival:
  Phi.quadratic.x.sex = list(formula = ~ quadratic + year)
  
  # Models exploring variation in encounter probability
  # constant:
  p.dot = list(formula = ~ 1)
  # quadratic across age
  p.quadratic = list(formula = ~ quadratic)
  # annual variation
  p.year = list(formula = ~ year)
  # interaction between year and quadratic age
  p.year.x.quadratic = list(formula = ~ year * quadratic)
  # additive effects of year and quadratic age
  p.year.quadratic = list(formula = ~ year + quadratic)
  
  # create a list of candidate models for all the a models above that begin with 
  # either "Phi." or "p."
  cml <-  RMark::create.model.list("CJS")
  
  # specify the data, design matrix, delete unneeded output files, and 
  # run the models in Program MARK
  model.list <-  RMark::mark.wrapper(cml, data = chick.proc, 
                                     ddl = chick.ddl, delete = TRUE)
  
  # output the model list and sotre the results
  return(model.list)
}

# Run the models on the bootstrapped data
chick_survival_year_age_run <- chick_survival_year_age()

# Extract the AIC model table from the model output
AIC_table_chick <- chick_survival_year_age_run$model.table

# Find the model number for the first ranked model of the AIC table
model_chick_num <- as.numeric(rownames(chick_survival_year_age_run$model.table[1,]))

# extract real parameter estimates from top models
chick_reals <- chick_survival_year_age_run[[model_chick_num]]$results$real

# format the output to tidy up the sex- and age-specific effects
Groups <- data.frame(str_split_fixed(rownames(chick_reals), " ", n = 5))
chick_reals <- cbind(Groups, chick_reals)
chick_reals <- chick_reals[which(chick_reals$X1 == "Phi"),]
chick_reals$year <-
  as.factor(str_sub(chick_reals$X2, 3, 6))

# transform the daily chick survival (DCS) to apparent hatching success
# by calculating the product of all DCS estimates:
chick_survival_real <- 
  chick_reals%>%
  dplyr::group_by(year)%>%
  dplyr::summarise(estimate = prod(estimate))
chick_survival_real$age <- "Chick"

# Bind the fledgling and adult dataframe with the chicks
survival_rates_year_age <- rbind(fledgling_adult_survival_real, chick_survival_real)
}
```
To save your time with re-running the survival analysis, here are the two datasets produced by the annual survival analyses:

- **output/bootstrap/survival_rates_year_age.txt** contains the stage- and year-specific survival estimates (*estimate*) of each year (*year*) in the study period. Each row represents a given stage (*age*) in a given year.

- **output/bootstrap/survival_rates_year_age_sex.txt** contains the sex- stage-, and year-specific survival estimates (*estimate*) of each year (*year*) in the study period. Each row represents a given sex and stage (*sex_age*) in a given year.

```{r}
survival_rates_year_age <- read.table(file = "~/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/data/survival_rates_year_age.txt", header = TRUE)
survival_rates_year_age_sex <- read.table(file = "~/Dropbox/Luke/R_projects/Ceuta_ASR_Matrix_Modeling/data/survival_rates_year_age_sex.txt", header = TRUE)
```
consolidate the year-specific vital rates into a list
```{r}
vital_rates_year <- list(S_Yr_Ag = survival_rates_year_age,
                         S_Yr_Ag_Sx = survival_rates_year_age_sex,
                         R_Yr_Sx = fecundity_annual_summary)
```
**year_plover_matrix()** function to build annual population projection matrices. If *two_sex* is set to TRUE, then it will build a two sex matrix for each year between *first_year* and *last_year* from the sex-specific vital rates provided in the *vital_rates_year* list. If FALSE, then it will build one-sex matrices.
```{r}
year_plover_matrix <- 
  function(vital_rates_year, first_year, last_year, two_sex = TRUE){
    # Build the matrix (note: NAs are assigned to cells where the mating 
    # function will go later)
    matrix_list <- vector("list", last_year)
    if(two_sex){
      # Define plover life-stages of the 2-sex Ceuta snowy plover matrix model
      stages <- c("F_1st_yr",  "F_Adt",  "M_1st_yr",  "M_Adt")
    for(i in first_year:(last_year-1)){
      result <- 
        matrix(c(0, NA, 0, NA, 
                 (vital_rates_year$S_Yr_Ag_Sx[which(vital_rates_year$S_Yr_Ag_Sx$sex_age == "Female_Chick" & vital_rates_year$S_Yr_Ag_Sx$year == i+1), 3] * 
                    vital_rates_year$S_Yr_Ag_Sx[which(vital_rates_year$S_Yr_Ag_Sx$sex_age == "Female_Fledgling" & vital_rates_year$S_Yr_Ag_Sx$year == i), 3]),
                 vital_rates_year$S_Yr_Ag_Sx[which(vital_rates_year$S_Yr_Ag_Sx$sex_age == "Female_Adult" & vital_rates_year$S_Yr_Ag_Sx$year == i), 3], 
                 0, 0,
                 0, NA, 0, NA,
                 0, 0, 
                 (vital_rates_year$S_Yr_Ag_Sx[which(vital_rates_year$S_Yr_Ag_Sx$sex_age == "Male_Chick" & vital_rates_year$S_Yr_Ag_Sx$year == i+1), 3] * 
                    vital_rates_year$S_Yr_Ag_Sx[which(vital_rates_year$S_Yr_Ag_Sx$sex_age == "Male_Fledgling" & vital_rates_year$S_Yr_Ag_Sx$year == i), 3]),
                 vital_rates_year$S_Yr_Ag_Sx[which(vital_rates_year$S_Yr_Ag_Sx$sex_age == "Male_Adult" & vital_rates_year$S_Yr_Ag_Sx$year == i), 3]), 
               nrow = length(stages), byrow = TRUE,
               dimnames = list(stages, stages))
      matrix_list[[i]] <- result
      }
    }
    else{
      # Define plover life-stages of the 1-sex Ceuta snowy plover matrix model
      stages <- c("1st_yr",  "Adt")
      for(i in first_year:(last_year-1)){
        result <- 
          matrix(c(0, vital_rates_year$R_Yr_Sx[which(vital_rates_year$R_Yr_Sx$Sex == "Male" & vital_rates_year$R_Yr_Sx$year == i+1), 4],
                   (vital_rates_year$S_Yr_Ag[which(vital_rates_year$S_Yr_Ag$age == "Chick" & vital_rates_year$S_Yr_Ag$year == i+1), 3] * 
                      vital_rates_year$S_Yr_Ag[which(vital_rates_year$S_Yr_Ag$age == "Fledgling" & vital_rates_year$S_Yr_Ag$year == i), 3]),
                   vital_rates_year$S_Yr_Ag[which(vital_rates_year$S_Yr_Ag$age == "Adult" & vital_rates_year$S_Yr_Ag$year == i), 3]), 
                 nrow = length(stages), byrow = TRUE,
                 dimnames = list(stages, stages))
        matrix_list[[i]] <- result
      }
    }
    matrix_list[c(first_year:(last_year-1))]
  }
```
run the function for the two-sex and one-sex models
```{r}
year_age_mats <- year_plover_matrix(vital_rates_year = vital_rates_year, first_year = 2006, last_year = 2012, two_sex = FALSE)
year_age_sex_mats <- year_plover_matrix(vital_rates_year = vital_rates_year, first_year = 2006, last_year = 2012, two_sex = TRUE)
```
store the results into a list
```{r}
year_mats <- list(two_sex_mats = year_age_sex_mats,
                  one_sex_mats = year_age_mats)
```
**stoch_projection_plover()** stochastically projects the population under the two-sex or one-sex model. In each iteration, the function randomly draws a matrix from the list and projects the population distribution *n0* at time 1 to time 2, then it randomly draws another matrix, and repeated the process until time *tmax*. The simulation is iterated for *nreps*.
```{r}
stoch_projection_plover <- 
  function (matrices, n0, tmax = 50, nreps = 5000, Quasi_Ex = 0, no_stages = 4, two_sex = TRUE, HSR, h = 1, k = 3) 
  {
    x <-  no_stages
    F_Adults <- matrix(numeric(nreps * tmax), nrow = nreps)
    F_Chicks <- matrix(numeric(nreps * tmax), nrow = nreps)
    M_Adults <- matrix(numeric(nreps * tmax), nrow = nreps)
    M_Chicks <- matrix(numeric(nreps * tmax), nrow = nreps)
    Chicks <- matrix(numeric(nreps * tmax), nrow = nreps)
    Adults <- matrix(numeric(nreps * tmax), nrow = nreps)
    lambda <- matrix(numeric(nreps * tmax), nrow = nreps)
    F_Adults[,1] <- n0[2]
    F_Chicks[,1] <- n0[1]
    M_Adults[,1] <- n0[4]
    M_Chicks[,1] <- n0[3]
    Chicks[,1] <- n0[1]
    if(two_sex){
      Adults[,1] <- n0[2] + n0[4]
    }
    else{
      Adults[,1] <- n0[2]
    }
    lambda[,1] <- NA
    for (i in 1:nreps) {
      if(two_sex){
        A <- sample(matrices$two_sex_mats, (tmax-1), replace = TRUE)
        for (j in 1:(tmax-1)) {
          n <- c(F_Chicks[i,j], F_Adults[i,j], M_Chicks[i,j], M_Adults[i,j])
          # number of male adults at time t
          M2 <- n[4] 
          # number of female adults at time t
          F2 <- n[2] 
          # Female freq-dep fecundity of Female chicks
          A[[j]][1,x/2]        <- (k*M2)/(M2+(F2*h))*HSR 
          # Female freq-dep fecundity of Male chicks
          A[[j]][(x/4)*3,x/2]  <- (k*M2)/(M2+(F2*h))*HSR
          # Male freq-dep fecundity of Female chicks
          A[[j]][1,x]          <- (k*F2)/(M2+(F2*h))*HSR 
          # Male freq-dep fecundity of Male chicks
          A[[j]][(x/4)*3,x]    <- (k*F2)/(M2+(F2*h))*HSR 
          # define the new n (i.e., new stage distribution at time t)
          B <- A[[j]] %*% n
          F_Chicks[i,(j+1)] <- B[1]
          F_Adults[i,(j+1)] <- B[2]
          M_Chicks[i,(j+1)] <- B[3]
          M_Adults[i,(j+1)] <- B[4]
          Adults[i,(j+1)] <- B[2] + B[4]
          lambda[i,(j+1)] <- sum(B[2],B[4])/sum(M2,F2)
        }
      }
      else{
        A <- sample(matrices$one_sex_mats, (tmax-1), replace = TRUE)
        for (j in 1:(tmax-1)) {
          B <- A[[j]] %*% c(Chicks[i,j], Adults[i,j])
          Chicks[i,(j+1)] <- B[1]
          Adults[i,(j+1)] <- B[2]
          lambda[i,(j+1)] <- B[2]/Adults[i,j]
        }
      }
    }  
    Adults_CV <- apply(Adults, 1, sd)/apply(Adults, 1, mean)
    Adults_Final <- Adults[,tmax]
    Adults_melted <- melt(t(Adults))
    lambda_melted <- melt(t(lambda))
    Adults_ExProb <- sum(Adults_Final < Quasi_Ex)/nreps
    colnames(Adults_melted) <- c("Year", "Iteration", "Adults")
    colnames(lambda_melted) <- c("Year", "Iteration", "lambda")
    Sim_Avg <- Adults_melted %>%
      dplyr::group_by(Year) %>%
      dplyr::summarise(year_avg = mean(Adults))
    Sim_Avg_lambda <- lambda_melted %>%
      dplyr::group_by(Iteration) %>%
      dplyr::summarise(iter_avg = mean(lambda, na.rm = TRUE))
    Adults <- list(Adults_CV = Adults_CV, Adults_ExProb = Adults_ExProb, 
                   Adults_Final = Adults_Final, Adults_melted = Adults_melted, 
                   lambda_melted = lambda_melted,
                   Sim_Avg = Sim_Avg, Sim_Avg_lambda = Sim_Avg_lambda)
    Adults
  }
```
Store the actual annual population size estimate from the field
```{r}
Actual <- c(198, 184, 98, 102, 131, 96, 58)
```
define the starting population distribution for the two-sex and one-sex models (format: female chicks,  female adults,  male chicks,  male adults)
```{r}
n_two_sex <- c(41, 97, 48, 101)
n_one_sex <- c(41 + 48, 97 + 101)
```
run the stochastic simulation for the two-sex and one-sex models
```{r}
two_sex_stoch_proj_year <- stoch_projection_plover(matrices = year_mats, n0 = n_two_sex, h = h,
                                            tmax = 7, nreps = 1000, Quasi_Ex = 2, HSR = HSR)

one_sex_stoch_proj_year <- stoch_projection_plover(matrices = year_mats, n0 = n_one_sex, 
                                                   tmax = 7, nreps = 1000, Quasi_Ex = 2, HSR = 0.5, no_stages = 2, two_sex = FALSE)
```
calculate the grand average lambda and 95% confidence intervals of the two-sex and one-sex models (i.e., average lambda of all iterations' average lambdas)
```{r}
two_sex_stoch_proj_year_summary <- 
  two_sex_stoch_proj_year$Sim_Avg_lambda%>%
  dplyr::summarise(grand_avg_lambda = mean(iter_avg),
                   lcl = quantile(iter_avg, (1 - 0.95)/2),
                   ucl = quantile(iter_avg, 1 - (1 - 0.95)/2))


one_sex_stoch_proj_year_summary <- 
  one_sex_stoch_proj_year$Sim_Avg_lambda%>%
  dplyr::summarise(grand_avg_lambda = mean(iter_avg),
                   lcl = quantile(iter_avg, (1 - 0.95)/2),
                   ucl = quantile(iter_avg, 1 - (1 - 0.95)/2))
```
Specify the years in the melted dataframe
```{r}
two_sex_stoch_proj_year$Adults_melted$Year <- 
  as.factor(c("2006", "2007", "2008", "2009", "2010", "2011", "2012"))
one_sex_stoch_proj_year$Adults_melted$Year <- 
  as.factor(c("2006", "2007", "2008", "2009", "2010", "2011", "2012"))
```
group the iterations by year and calculate the annual average population size
```{r}
two_sex_yearly_averages <- two_sex_stoch_proj_year$Adults_melted %>%
  dplyr::group_by(Year) %>%
  dplyr::summarise(two_sex_yr_avg_pop = mean(Adults))
one_sex_yearly_averages <- one_sex_stoch_proj_year$Adults_melted %>%
  dplyr::group_by(Year) %>%
  dplyr::summarise(one_sex_yr_avg_pop = mean(Adults))
```
Tidy up summary dataframe
```{r}
two_sex_yearly_averages$actual_yr_pop <- Actual
two_sex_yearly_averages <- melt(two_sex_yearly_averages)
colnames(two_sex_yearly_averages) <- c("Year", "Model", "Pop_size")
one_sex_yearly_averages <- melt(one_sex_yearly_averages)
colnames(one_sex_yearly_averages) <- c("Year", "Model", "Pop_size")
yearly_averages <- rbind(two_sex_yearly_averages, one_sex_yearly_averages)
```
calculate the average of the actual lambda
```{r}
Actual_lambda <- sum(Actual[2]/Actual[1], 
                     Actual[3]/Actual[2], 
                     Actual[4]/Actual[3], 
                     Actual[5]/Actual[4], 
                     Actual[6]/Actual[5], 
                     Actual[7]/Actual[6])/(length(Actual)-1)
```
plot the actual vs. the predicted trajectories of the two-sex and one-sex models between 2006 and 2012.
```{r, fig.width=4, fig.height=4, fig.align="center"}
# ggplot(NULL) +  
#   theme_bw() +
#   geom_line(data = one_sex_stoch_proj_year$Adults_melted, 
#             aes(x = Year, y = Adults, group = Iteration), 
#             size = 0.25,  alpha = 0.05, stat = "smooth", 
#             method = "lm", formula = y ~ poly(x,3),
#             color = "red") +
#   geom_line(data = filter(yearly_averages, Model == "one_sex_yr_avg_pop"), 
#             aes(x = Year, y = Pop_size, group = Model), 
#             size = 1,  alpha = 1, color = brewer.pal(8, "Set1")[c(1)]) +
#   geom_line(data = two_sex_stoch_proj_year$Adults_melted, 
#             aes(x = Year, y = Adults, group = Iteration), 
#             size = 0.25,  alpha = 0.05, stat = "smooth", 
#             method = "lm", formula = y ~ poly(x,3)) +
#   geom_line(data = filter(yearly_averages, Model == "two_sex_yr_avg_pop"), 
#             aes(x = Year, y = Pop_size, group = Model), #, color = cbPalette), 
#             size = 1,  alpha = 1, color = "black") +
#   geom_line(data = filter(yearly_averages, Model == "actual_yr_pop"), 
#             aes(x = Year, y = Pop_size, group = Model), #, color = cbPalette), 
#             size = 1,  alpha = 1, color = brewer.pal(8, "Set1")[c(2)]) +
#   theme(legend.position = c(1, 1), 
#         legend.justification = c(1, 1),
#         legend.background = element_rect(fill=NA),
#         legend.text = element_text(size=7),
#         legend.title = element_blank(),
#         legend.key.height = unit(0.8,"line"),
#         legend.key.width = unit(0.8,"line"),
#         axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
#         axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)), 
#         axis.title.y = element_text(size=12, margin = margin(0, 15, 0, 0)),
#         axis.text.y  = element_text(size=10, angle = 0, hjust = 0.5, 
#                                     margin = margin(0, 1, 0, 0)),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
#         axis.ticks.length = unit(0.2, "cm"),
#         axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
#         panel.border = element_rect(linetype = "solid", colour = "grey"),
#         plot.margin = unit(c(1,0.5,0.5,0.5), "cm"),
#         panel.margin = unit(0.75, "lines"),
#         strip.background = element_blank(), 
#         strip.text = element_blank()) +
#   xlab("Year") +
#   ylab("Breeding population size") +
#   scale_y_continuous(limits = c(0, 250))
```
tidy up the data-frame for the plot legend
```{r}
two_sex_stoch_proj_year$Sim_Avg_lambda$Matrix <- "Two-sex model"
two_sex_stoch_proj_year$Sim_Avg_lambda$Matrix <- as.factor(two_sex_stoch_proj_year$Sim_Avg_lambda$Matrix)
one_sex_stoch_proj_year$Sim_Avg_lambda$Matrix <- "One-sex model     "
one_sex_stoch_proj_year$Sim_Avg_lambda$Matrix <- as.factor(one_sex_stoch_proj_year$Sim_Avg_lambda$Matrix)
test <- rbind(two_sex_stoch_proj_year$Sim_Avg_lambda, one_sex_stoch_proj_year$Sim_Avg_lambda)
test$Matrix <- factor(test$Matrix, levels = c("One-sex model     ", "Two-sex model"))
```
plot the actual vs. the predicted lambda distributions of the two-sex and one-sex model simulations between 2006 and 2012.
```{r, fig.width=4, fig.height=3.5, fig.align="center"}
cbPalette <- c(brewer.pal(8, "Set1")[c(1)], brewer.pal(9, "Greys")[c(9)])
lambda_stoch_histogram <- 
ggplot() +
  geom_histogram(binwidth = 0.003, data = filter(test, Matrix == "Two-sex model"),
                 aes(x = iter_avg, fill = Matrix), alpha = 0.7) +
  geom_histogram(binwidth = 0.003, data = filter(test, Matrix == "One-sex model     "),
                 aes(x = iter_avg, fill = Matrix), alpha = 0.7) +
  geom_vline(xintercept = Actual_lambda, color = brewer.pal(8, "Set1")[c(2)], size=1) +
  geom_errorbarh(data = two_sex_stoch_proj_year_summary,
                 aes(y = 115, x = lcl, xmin = lcl, xmax = ucl),
                 color = "black", size = 0.8, linetype = "solid") +
  geom_errorbarh(data = one_sex_stoch_proj_year_summary,
                 aes(y = 110, x = lcl, xmin = lcl, xmax = ucl), 
                 color = brewer.pal(8, "Set1")[c(1)], size = 0.8, linetype = "solid") +
  theme_bw() +
  theme(#text = element_text(family="Arial"),
        legend.text = element_text(size = 8),
        legend.title = element_blank(),
        legend.position = "top",
        legend.key.height=unit(0.6,"line"),
        legend.key.width=unit(0.6,"line"),
        axis.title.x = element_text(size=12, margin = margin(10, 0, 0, 0)),
        axis.text.x  = element_text(size=10, margin = margin(5, 0, 0, 0)), 
        axis.title.y = element_text(size=12, margin = margin(0, 43, 0, 0)),
        axis.text.y  = element_text(size=10, angle = 0, hjust = 1, 
                                    margin = margin(0, 1, 0, 0)),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks.y = element_line(size = 0.5, colour = "grey40"),
        axis.ticks.length = unit(0.2, "cm"),
        axis.ticks.x = element_line(size = 0.5, colour = "grey40"),
        panel.border = element_rect(linetype = "solid", colour = "grey"),
        plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
        panel.margin = unit(0.75, "lines"),
        strip.background = element_blank(), 
        strip.text = element_blank()) +
  ylab("Frequency") +
  xlab("Population growth rate") +
  # xlab("Population growth rate (\u03BB)") +
  scale_y_continuous(limits = c(0, 120)) +
  scale_fill_manual(values = cbPalette)
lambda_stoch_histogram
# ggsave(lambda_stoch_histogram,
#        filename = "lambda_stoch_histogram_compare_2_v_1.jpg",
#        path = "figs/final/final_final",
#        width = 4,
#        height = 3.5, units = "in",
#        dpi = 300,
#        scale = 1)
```

***
## R session information

```{r}
sessionInfo()
```